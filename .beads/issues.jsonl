{"id":"test-loom-27c","title":"Implement enricher pipeline with pluggable interfaces","description":"internal/enricher/ - Enricher interface + 5 implementations: grouper (by package), patterns (no-op), simplifier (prune+cap), annotator (no-op), scorer (equal weight). All have LLM-ready interfaces for iteration 2.","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:56.360211-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:06:00.702199-06:00","closed_at":"2026-02-19T09:06:00.702199-06:00","close_reason":"All 5 enricher files implemented with default code-only implementations"}
{"id":"test-loom-2ul","title":"Fix color differentiation not rendering in browser for interfaces vs implementations","description":"The classDef and cssClass directives for color-coding interfaces (blue #2374ab) vs implementations (green #4a9c6d) are present in the generated Mermaid source but not rendering visually in the browser. The styles were added in mermaid.go but may not be taking effect with Mermaid.js v11 in-browser rendering. Need to investigate why and fix.","status":"closed","priority":1,"issue_type":"bug","owner":"olesho@gmail.com","created_at":"2026-02-19T16:25:51.602997-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:43:48.291601-06:00","closed_at":"2026-02-19T16:43:48.291601-06:00","close_reason":"Closed"}
{"id":"test-loom-6oq","title":"Create initial git commit for goifaces","description":"Stage all project files and create the initial commit. Verify pre-commit hook runs lint + tests successfully. Do NOT commit logs/ or testdata/*/output.* files (gitignored).","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:44.018283-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T10:55:38.076036-06:00","closed_at":"2026-02-19T10:55:38.076036-06:00","close_reason":"Initial commit 9f31a3a created. Pre-commit hook verified lint + tests pass."}
{"id":"test-loom-6t1","title":"Implement input resolver package","description":"internal/resolver/resolver.go - resolves local dirs, sub-package paths, and GitHub URLs (git clone --depth=1) to analyzable directories","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:48.459913-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:05:52.258219-06:00","closed_at":"2026-02-19T09:05:52.258219-06:00","close_reason":"Implemented with local dir, GitHub URL clone, and go mod download"}
{"id":"test-loom-720","title":"Create Mermaid syntax verifier for CI and development","description":"Add a verification step that validates generated Mermaid code against Mermaid.js parser (not just mmdc CLI). Should catch syntax errors before serving to browser. Can use Node.js mermaid package or mmdc --parseOnly.","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T16:07:55.764085-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:11:04.387828-06:00","closed_at":"2026-02-19T16:11:04.387828-06:00","close_reason":"Closed"}
{"id":"test-loom-7r8","title":"Implement structured logging package","description":"internal/logging/logging.go - slog JSON handler with dual output (stderr + file), Setup function returning logger and cleanup","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:30.406814-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:05:35.054043-06:00","closed_at":"2026-02-19T09:05:35.054043-06:00","close_reason":"Implemented with slog JSONHandler and io.MultiWriter"}
{"id":"test-loom-86t","title":"Implement Mermaid diagram generator","description":"internal/diagram/mermaid.go - generates deterministic classDiagram syntax with sanitized IDs, method truncation, and sorted output","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:06:05.360739-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:06:09.108986-06:00","closed_at":"2026-02-19T09:06:09.108986-06:00","close_reason":"Implemented with deterministic sorting, relevant method filtering, and pointer-receiver labels"}
{"id":"test-loom-873","title":"Mermaid syntax error in browser - Unicode sanitization chars not supported by Mermaid.js v11","description":"The sanitizeSignature() function in internal/diagram/mermaid.go replaces {}\u003c\u003e with Unicode alternatives (⦃⦄ᐊ‹›) that pass mmdc CLI rendering but fail in browser Mermaid.js v11.12.3. Need to use only ASCII-safe replacements that work in both contexts.","status":"closed","priority":1,"issue_type":"bug","owner":"olesho@gmail.com","created_at":"2026-02-19T15:48:38.349512-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:11:04.294301-06:00","closed_at":"2026-02-19T16:11:04.294301-06:00","close_reason":"Closed"}
{"id":"test-loom-944","title":"Replace Overview slide with package map visualization","description":"Replace the first 'Overview' slide with a visualization showing the map of all packages in the repository. Each package may contain subpackages (nested). Use a different Mermaid chart type suitable for hierarchical package visualization. The existing detail slides (split into many slides showing interfaces/implementations) should remain unchanged.","design":"## Summary\n\nReplace the Overview slide (slide 0) with a Package Map visualization that shows the hierarchical structure of all Go packages in the analyzed repository. Currently, the overview slide shows a classDiagram with only interface nodes and embedding arrows. The new package map will use a Mermaid flowchart with nested subgraphs to represent the package tree, giving users an at-a-glance understanding of the project's package organization and where interfaces and types live. The existing detail slides (interface+implementation diagrams split by hub-and-spoke) remain unchanged.\n\n## Technical Approach\n\n**Mermaid chart type:** `flowchart TD` (top-down) with nested subgraphs. This is the most natural and well-supported Mermaid representation for hierarchical data. Each package becomes a `subgraph` labeled with its short name, and nested packages become nested subgraphs. Leaf/inner packages with interfaces or types get an info node showing counts (e.g., \"3 interfaces · 5 types\").\n\n**Key design decisions:**\n- Use `flowchart TD` instead of `classDiagram` — subgraphs naturally represent package containment\n- Strip the module path prefix to show only relative package paths (e.g., `internal/analyzer` instead of `github.com/foo/bar/internal/analyzer`)\n- Build an in-memory package tree from `PkgPath` strings, filling in intermediate nodes that may not directly contain types\n- Show interface/type counts per package as info nodes within subgraphs\n- Style subgraphs with the existing blue color scheme for visual consistency\n\n**Trade-offs:**\n- Flowchart subgraphs vs block-beta: Flowchart subgraphs are more mature and widely supported in Mermaid v11. Block-beta is newer but less tested.\n- Showing counts vs individual type names: Counts keep the map clean and readable. Individual names would create visual clutter — that's what the detail slides are for.\n- Mermaid subgraph nesting depth: Works well for typical Go projects (2-4 levels). Very deep nesting (5+) may render awkwardly, but this is rare in practice.\n\n## Files to Create\n\n### `goifaces/internal/diagram/pkgmap.go`\nNew file containing the package map generation logic:\n- `type pkgNode struct` — tree node: name, full path, children map, interface count, type count\n- `func buildPackageTree(result *analyzer.Result) *pkgNode` — extracts unique PkgPaths from interfaces and types, strips common module prefix, builds tree\n- `func generatePackageMapMermaid(result *analyzer.Result, opts DiagramOptions) string` — renders the package tree as a Mermaid `flowchart TD` with nested subgraphs\n- Helper: `func longestCommonPathPrefix(paths []string) string` — finds module path to strip\n- Helper: `func renderSubgraph(b *strings.Builder, node *pkgNode, depth int)` — recursive subgraph renderer\n\nThe flowchart output will look like:\n```\nflowchart TD\n    subgraph root[\"mymodule\"]\n        subgraph internal_sg[\"internal\"]\n            subgraph analyzer_sg[\"analyzer\"]\n                analyzer_info[\"3 interfaces · 5 types\"]\n            end\n            subgraph diagram_sg[\"diagram\"]\n                diagram_info[\"1 interface\"]\n                subgraph split_sg[\"split\"]\n                    split_info[\"1 interface · 1 type\"]\n                end\n            end\n        end\n    end\n```\n\nSubgraph IDs use `{sanitizedPkgName}_sg` pattern to avoid collisions with existing node ID conventions. Info nodes use `{sanitizedPkgName}_info`.\n\nFor packages with no direct types/interfaces (pure organizational packages), no info node is rendered — they appear as empty subgraphs containing only their children.\n\n### `goifaces/internal/diagram/pkgmap_test.go`\nUnit tests for the package tree building and rendering:\n- `TestBuildPackageTree` — verifies tree structure from sample PkgPaths\n- `TestLongestCommonPathPrefix` — edge cases: single package, no common prefix, identical paths\n- `TestGeneratePackageMapMermaid` — verifies Mermaid output contains expected subgraphs and info nodes\n\n## Files to Modify\n\n### `goifaces/internal/diagram/slides.go`\n**Lines 45-49:** Replace the `generateOverviewMermaid` call with `generatePackageMapMermaid`:\n```go\n// Slide 0: package map — hierarchical view of all packages\nslides = append(slides, Slide{\n    Title:   \"Package Map\",\n    Mermaid: generatePackageMapMermaid(result, diagOpts),\n})\n```\n\n**Lines 108-215:** Remove the entire `generateOverviewMermaid` function and `collectEmbeddingArrows` function. These are only used for the old overview slide and will be replaced by the new pkgmap.go code.\n\n### `goifaces/internal/integration_test.go`\n**`TestHubAndSpokeSlides` (line 328):**\n- Change `assert.Equal(t, \"Overview\", slides[0].Title)` to `assert.Equal(t, \"Package Map\", slides[0].Title)`\n- Update assertions about overview content: instead of checking for interface nodes and embedding arrows, check for flowchart subgraph markers (e.g., `subgraph`, package names)\n- Keep the assertion that impl types don't appear (they shouldn't be in the package map either)\n- Keep the detail slide assertions unchanged\n\n**`TestOverviewInterfaceEmbedding` (line 449):**\nRewrite this test as `TestPackageMapSlide`:\n- Create a synthetic Result with types in multiple packages (e.g., `example.com/app/models`, `example.com/app/handlers`, `example.com/app/handlers/middleware`)\n- Verify the package map slide contains subgraphs for each package level\n- Verify package counts are shown correctly\n- Verify the flowchart chart type is used (contains \"flowchart\")\n- Verify no classDiagram artifacts appear\n\n### `goifaces/docs/architecture.md`\n**Line 62 (internal/diagram section):** Update the description of the overview slide:\n- Change \"The overview (first) slide shows only interface nodes with interface→interface embedding/extension arrows\" to \"The overview (first) slide shows a Package Map — a hierarchical flowchart visualization of all Go packages using nested subgraphs, with interface/type counts per package\"\n\n## Dependencies\n\n- No new external packages needed\n- Internal: `analyzer.Result` (existing), `DiagramOptions` (existing)\n- The `go/types` import in slides.go can be removed since `collectEmbeddingArrows` (which uses it) is being deleted\n\n## Edge Cases \u0026 Error Handling\n\n1. **Single package (no nesting):** If all types are in one package, render a single subgraph with an info node. No nested subgraphs needed.\n2. **No types/interfaces found:** Return a minimal `flowchart TD` with just \"No packages found\" text node. (This case is already handled upstream — the pipeline exits early if result is empty.)\n3. **Very deep nesting (5+ levels):** Mermaid handles this, though rendering may be less ideal. No special handling needed — Go projects rarely exceed 4 levels.\n4. **Packages with identical short names (e.g., `foo/bar` and `baz/bar`):** Node IDs must be unique. Use the full relative path (sanitized) as the subgraph ID, not just the short name.\n5. **Module prefix stripping:** If all types share a common module prefix (e.g., `github.com/user/repo`), strip it. If only one package exists, use just its short name. If packages come from different modules (e.g., stdlib included), find the longest common prefix at `/` boundaries.\n6. **Empty intermediate packages:** Packages like `internal/` that have no direct types but contain subpackages should still appear as subgraph containers.\n7. **Special characters in package names:** Already handled by existing `sanitizeID` function (replaces `/`, `.`, `-` with `_`).\n\n## Testing Strategy\n\n### Unit Tests (pkgmap_test.go)\n1. **TestBuildPackageTree:** Verify tree building from various PkgPath inputs:\n   - Multiple packages at different depths\n   - Single package (flat)\n   - Packages with shared prefixes\n2. **TestLongestCommonPathPrefix:** Test edge cases:\n   - Empty input → empty string\n   - Single path → the path itself up to last segment\n   - Two paths with partial overlap\n   - Identical paths\n3. **TestGeneratePackageMapMermaid:**\n   - Verify output starts with \"flowchart TD\"\n   - Verify subgraph nesting matches package hierarchy\n   - Verify info nodes contain correct counts\n   - Verify sanitized IDs are used\n\n### Integration Tests (integration_test.go)\n4. **TestHubAndSpokeSlides (updated):** Verify package map is slide 0 with correct title\n5. **TestPackageMapSlide (new):** End-to-end test with multi-package synthetic data\n\n### Manual Verification\n6. Run `bash scripts/visual-verify.sh` after implementation\n7. Run the tool on a real Go project and verify the package map renders correctly in the browser","status":"closed","priority":2,"issue_type":"feature","owner":"olesho@gmail.com","created_at":"2026-02-21T08:07:36.726755-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-21T08:13:08.281729-06:00","closed_at":"2026-02-21T08:13:08.281729-06:00","close_reason":"Replaced Overview slide with Package Map flowchart showing package hierarchy with interface/type counts"}
{"id":"test-loom-9q0","title":"Show only interfaces and relations on the first (overview) slide","description":"The first Mermaid chart, titled 'Overview', currently shows interfaces, implementations, and all details. It should instead be a unified map showing ONLY interfaces and their relations (dependency arrows between interfaces). No implementation blocks, no method bodies — just the interface nodes and how they connect. Only modify the 'Overview' chart; the chunked slides that follow should keep their current detail level.","design":"## Summary\n\nThe overview (first) slide currently shows ALL nodes (interfaces and implementations) with empty class bodies plus all type→interface relation arrows. This task changes the overview to show ONLY interface nodes and interface→interface embedding/extension arrows, producing a clean architectural map. Implementation blocks and implementation arrows are omitted entirely from the overview — they remain on the detail slides that follow.\n\n## Technical Approach\n\nThe change is localized to `generateOverviewMermaid()` in `internal/diagram/slides.go`. The function already has special logic for the overview (no method bodies). We extend this by:\n\n1. **Removing type/implementation blocks** — Delete the entire section that renders type class blocks (lines 168-177 in current code).\n2. **Replacing type→interface relations with interface→interface embedding arrows** — Instead of iterating `result.Relations` (which are type→interface), detect interface embedding using each `InterfaceDef.TypeObj` (`*types.Interface`). The `NumEmbeddeds()` and `EmbeddedType(i)` methods from Go's `go/types` package reveal which interfaces embed other interfaces.\n3. **Using a different arrow style** — Implementation uses `..|\u003e` (dashed + triangle). Interface embedding/extension should use `--|\u003e` (solid + triangle), following UML convention for inheritance/extension.\n4. **Handling nil TypeObj** — Synthetic test data may have nil `TypeObj`. When nil, skip embedding detection for that interface (no arrows drawn from it).\n5. **Removing implStyle** — Since no implementation blocks are rendered, remove `classDef implStyle` and its `cssClass` assignments from the overview output.\n\nIf a codebase has no interface embedding, the overview shows just the interface nodes (a useful \"table of contents\"). The detail slides remain unchanged.\n\n## Files to Modify\n\n### 1. `internal/diagram/slides.go` — `generateOverviewMermaid()`\n\n**Remove type blocks section (current lines ~168-177):**\n- Delete the loop that writes type class blocks\n- Delete the blank-line separator between interfaces and types\n\n**Replace relation rendering (current lines ~179-186):**\n- Remove the loop that writes `type ..|\u003e interface` arrows\n- Add new logic:\n  a. Build a lookup map: `pkgPath.Name → bool` for all interfaces in the result\n  b. For each interface with non-nil `TypeObj`, iterate `TypeObj.NumEmbeddeds()`\n  c. For each `TypeObj.EmbeddedType(i)`, check if it's a `*types.Named` whose `Obj().Pkg().Path() + \".\" + Obj().Name()` exists in the lookup\n  d. If so, write an embedding arrow: `childID --|\u003e parentID`\n  e. Sort embedding arrows deterministically\n\n**Remove implStyle references (current lines ~189-198):**\n- Remove `classDef implStyle ...` line from style definitions\n- Remove the loop that assigns `cssClass` to type nodes (since no type nodes exist)\n\n**Add a new helper function `writeEmbeddingRelation()`:**\n```go\nfunc writeEmbeddingRelation(b *strings.Builder, child, parent analyzer.InterfaceDef) {\n    childID := nodeID(child.PkgName, child.Name)\n    parentID := nodeID(parent.PkgName, parent.Name)\n    b.WriteString(fmt.Sprintf(\"    %s --|\u003e %s\", childID, parentID))\n}\n```\n\n### 2. `internal/integration_test.go` — `TestHubAndSpokeSlides`\n\n**Update overview assertions (around line 421-423):**\n- Keep the existing `assert.NotContains(t, overview, \"+\", \"overview should have no method lines\")` assertion\n- Add: overview should NOT contain any implementation node IDs (e.g., `memdb_BoolFieldIndex`, `memdb_FilterIterator`)\n- Add: overview should NOT contain `..|\u003e` arrows (implementation relations)\n- Add: overview SHOULD contain interface node IDs (`memdb_Indexer`, `memdb_MultiIndexer`, etc.)\n\n**Add a new test `TestOverviewInterfaceEmbedding`:**\n- Create synthetic data with 3 interfaces where one embeds the other two (like ReadCloser embedding Reader and Closer)\n- Use real `*types.Interface` objects (via `types.NewInterfaceType`) so `TypeObj` is populated\n- Verify the overview contains `--|\u003e` arrows between the embedding interface and its parents\n- Verify no implementation blocks or `..|\u003e` arrows appear\n\n### 3. `docs/architecture.md` — Update `internal/diagram` section\n\nUpdate the paragraph describing the diagram package to mention that the overview slide shows only interface nodes with embedding/extension arrows (`--|\u003e`), while detail slides show full interface+implementation diagrams with implementation arrows (`..|\u003e`).\n\n## Dependencies\n\n- No new external packages needed\n- Uses existing `go/types` stdlib for embedding detection (`types.Interface.NumEmbeddeds()`, `types.Interface.EmbeddedType()`)\n- No dependency on in-progress task test-loom-xf7 (that task modifies detail slide rendering in `mermaid.go`, not overview in `slides.go`)\n\n## Edge Cases \u0026 Error Handling\n\n1. **Nil TypeObj** — Synthetic test data or edge cases may have nil `TypeObj`. Skip embedding detection for these interfaces; they'll render as disconnected nodes.\n2. **Self-embedding** — Go doesn't allow it, but guard: skip if child == parent by key.\n3. **Embedded type is not *types.Named** — `EmbeddedType(i)` could return a non-Named type (e.g., type constraints in generics). Only process `*types.Named` types.\n4. **Embedded interface not in result set** — If an interface embeds a stdlib interface not in our result (e.g., `io.Reader`), skip the arrow since the parent node doesn't exist in the diagram.\n5. **No interfaces at all** — The overview renders just `classDiagram` with no nodes. This matches current behavior for empty results.\n6. **No embeddings** — Overview shows interface nodes with no arrows. This is correct — it serves as a table of contents.\n7. **Embedded type's Obj().Pkg() is nil** — Universe-scope types like `error` have nil Pkg(). Handle this by checking for nil before accessing `Pkg().Path()`.\n\n## Testing Strategy\n\n1. **Existing test `TestHubAndSpokeSlides`** — Update assertions for overview slide to verify no impl nodes and no `..|\u003e` arrows\n2. **New test `TestOverviewInterfaceEmbedding`** — Verify embedding arrows appear correctly using synthetic interface types\n3. **Manual verification** — Run on testdata/05_embedded_iface to verify ReadCloser → Reader and ReadCloser → Closer arrows appear in overview\n4. **Run `go test ./...`** — All existing tests must pass\n5. **Run `golangci-lint run ./...`** — No lint errors\n6. **Run `bash scripts/visual-verify.sh`** — Visual check of rendered SVGs","status":"closed","priority":2,"issue_type":"task","assignee":"nova","owner":"olesho@gmail.com","created_at":"2026-02-20T05:08:13.910905-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-20T09:31:21.174566-06:00","closed_at":"2026-02-20T09:31:21.174566-06:00","close_reason":"Completed: overview slide now shows only interface nodes with embedding arrows (--|\u003e). Implementation blocks, impl arrows (..|\u003e), and implStyle removed. Tests updated and new TestOverviewInterfaceEmbedding added."}
{"id":"test-loom-a0i","title":"Implement HTTP server with Mermaid.js rendering","description":"internal/server/server.go - serves HTML with Mermaid.js CDN v11, zoom controls, copy button, auto-browser-open, graceful shutdown","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:06:16.076028-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:06:19.490009-06:00","closed_at":"2026-02-19T09:06:19.490009-06:00","close_reason":"Implemented with dark/light mode, zoom, copy, and graceful shutdown"}
{"id":"test-loom-a8u","title":"Implement core analyzer package","description":"internal/analyzer/ - types.go (InterfaceDef, TypeDef, MethodSig, Relation, Result), analyzer.go (package loading via go/packages, interface/type collection, types.Implements matching), filter.go (stdlib/unexported/prefix filtering, orphan pruning)","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:39.671251-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:05:44.098826-06:00","closed_at":"2026-02-19T09:05:44.098826-06:00","close_reason":"Implemented with stdlib interface loading, error builtin handling, and all filtering"}
{"id":"test-loom-awj","title":"Mermaid syntax error when rendering go-memdb diagram in browser","description":"Running './goifaces https://github.com/hashicorp/go-memdb -port 8081' produces a Mermaid diagram that fails to render in the browser with 'Syntax error in text, mermaid version 11.12.3'. Need to investigate the generated Mermaid output for invalid syntax.","status":"closed","priority":1,"issue_type":"bug","owner":"olesho@gmail.com","created_at":"2026-02-19T15:38:56.242547-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T15:42:24.034549-06:00","closed_at":"2026-02-19T15:42:24.034549-06:00","close_reason":"Closed"}
{"id":"test-loom-ayh","title":"Run visual verification on all test diagrams","description":"Run 'bash scripts/visual-verify.sh' to render all testdata Mermaid outputs to SVG via mmdc. Then visually inspect each SVG to confirm diagrams match the input Go code. Prerequisite: npm install -g @mermaid-js/mermaid-cli","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:40.313985-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:47:39.122746-06:00","closed_at":"2026-02-19T16:47:39.122746-06:00","close_reason":"Closed"}
{"id":"test-loom-bnt","title":"Implement LLM-backed enrichers (iteration 2)","description":"Swap no-op default enrichers with LLM-backed implementations: 1) Semantic grouper - identify architectural layers 2) Pattern detector - recognize design patterns 3) Diagram simplifier - intelligent pruning 4) Annotator - add descriptions 5) Relationship scorer - rank by importance. All interfaces already defined in internal/enricher/.","design":"## Summary\n\nReplace the five no-op/mechanical default enrichers with LLM-backed implementations that provide semantic understanding of Go interface-implementation graphs. This transforms the enricher pipeline from purely syntactic (group-by-package, equal-weight scoring) to semantically intelligent (identify architectural layers, recognize design patterns, smart pruning, human-readable annotations, importance-based scoring). The LLM enrichers degrade gracefully to the existing defaults on failure.\n\n## Technical Approach\n\n### LLM Client Abstraction\n\nCreate a lightweight LLM client in \\`internal/enricher/llm/client.go\\` that speaks the **OpenAI-compatible chat completions API** (the most universal protocol — works with OpenAI, Anthropic via proxy, Ollama, vLLM, any OpenAI-compatible endpoint). No external SDK dependency — use stdlib \\`net/http\\` + \\`encoding/json\\`.\n\nThe client:\n- Takes an endpoint URL, API key, and model name via configuration\n- Sends chat completion requests with JSON mode (\\`response_format: {type: \"json_object\"}\\`)\n- Returns raw JSON string for each enricher to parse into its own typed response\n- Includes timeout, retries (1 retry on 5xx), and structured logging via \\`slog\\`\n\n### Configuration\n\nAdd a CLI flag \\`--enrich\\` (boolean, default false) to enable LLM enrichment. When enabled, read:\n- \\`GOIFACES_LLM_ENDPOINT\\` — API base URL (default: \\`https://api.openai.com/v1\\`)\n- \\`GOIFACES_LLM_API_KEY\\` — API key (required when --enrich is set)\n- \\`GOIFACES_LLM_MODEL\\` — model identifier (default: \\`gpt-4o-mini\\`)\n\nThese are env vars rather than flags because they contain secrets (API key) and rarely change between runs.\n\n### Enricher Implementations\n\nEach LLM enricher lives in a new file \\`internal/enricher/llm_\u003cname\u003e.go\\` (e.g., \\`llm_grouper.go\\`). Each:\n1. Implements the existing \\`Enricher\\` interface plus its domain-specific interface\n2. Takes a \\`*llm.Client\\` and the default enricher as constructor args\n3. Serializes the relevant parts of \\`analyzer.Result\\` into a focused prompt\n4. Parses the JSON response into the expected return type\n5. Falls back to the default enricher on any error (logs the failure at WARN level)\n\n#### 1. LLM Semantic Grouper (\\`llm_grouper.go\\`)\n\n**Prompt strategy:** Send a list of interfaces and types with their package paths, method signatures, and implementation relationships. Ask the LLM to identify architectural layers/domains (e.g., \"Data Access\", \"Business Logic\", \"HTTP Transport\", \"Domain Models\").\n\n**JSON response schema:**\n\\`\\`\\`json\n{\n  \"groups\": [\n    {\n      \"name\": \"Data Access Layer\",\n      \"interfaces\": [\"pkg.InterfaceName\"],\n      \"types\": [\"pkg.TypeName\"]\n    }\n  ]\n}\n\\`\\`\\`\n\n**Enrich behavior:** The \\`Enrich()\\` method returns the result unchanged (grouping is consumed separately by diagram generation). The \\`Group()\\` method returns the LLM-identified semantic groups.\n\n#### 2. LLM Pattern Detector (\\`llm_patterns.go\\`)\n\n**Prompt strategy:** Send the interface graph (interfaces with methods, types, which type implements which interface). Ask the LLM to identify GoF and Go-specific patterns (Strategy, Factory, Repository, Observer, Decorator, Adapter, etc.).\n\n**JSON response schema:**\n\\`\\`\\`json\n{\n  \"patterns\": [\n    {\n      \"name\": \"Strategy\",\n      \"description\": \"Multiple interchangeable algorithms behind a common interface\",\n      \"participants\": [\"pkg.Interface\", \"pkg.ImplA\", \"pkg.ImplB\"]\n    }\n  ]\n}\n\\`\\`\\`\n\n**Enrich behavior:** \\`Enrich()\\` returns result unchanged. \\`Detect()\\` returns detected patterns.\n\n#### 3. LLM Diagram Simplifier (\\`llm_simplifier.go\\`)\n\n**Prompt strategy:** When node count exceeds \\`maxNodes\\`, send the full graph and ask the LLM to identify the \\`maxNodes\\` most architecturally significant nodes to keep, preserving the most informative relationships. The LLM should prefer keeping hub interfaces and types that bridge different domains.\n\n**JSON response schema:**\n\\`\\`\\`json\n{\n  \"keep\": [\"pkg.Name1\", \"pkg.Name2\"]\n}\n\\`\\`\\`\n\n**Enrich behavior:** \\`Enrich()\\` uses the LLM to intelligently select which nodes to keep (rather than the default edge-count heuristic). \\`Simplify()\\` performs the actual filtering based on the LLM's selection.\n\n#### 4. LLM Annotator (\\`llm_annotator.go\\`)\n\n**Prompt strategy:** Send interfaces and types with their methods and relationships. Ask the LLM to generate concise (\u003c 80 char) human-readable descriptions for each, explaining their role/purpose.\n\n**JSON response schema:**\n\\`\\`\\`json\n{\n  \"annotations\": {\n    \"pkg.Name\": \"Brief description of purpose\"\n  }\n}\n\\`\\`\\`\n\n**Enrich behavior:** \\`Enrich()\\` returns result unchanged. \\`Annotate()\\` returns the annotation map.\n\n#### 5. LLM Relationship Scorer (\\`llm_scorer.go\\`)\n\n**Prompt strategy:** Send all relationships (type → interface pairs). Ask the LLM to score each by architectural importance (0.0–1.0), where core domain relationships score high and incidental implementations (e.g., implementing \\`error\\` or \\`fmt.Stringer\\`) score low.\n\n**JSON response schema:**\n\\`\\`\\`json\n{\n  \"scores\": {\n    \"0\": 0.9,\n    \"1\": 0.3\n  }\n}\n\\`\\`\\`\n\nKeys are string-encoded relation indices matching the input order.\n\n**Enrich behavior:** \\`Enrich()\\` returns result unchanged. \\`Score()\\` returns the weighted scores.\n\n### Result Serialization\n\nCreate a helper \\`internal/enricher/llm/serialize.go\\` that converts \\`analyzer.Result\\` into a compact text representation for prompts:\n- List interfaces: name, package, method signatures (truncated if \u003e10 methods)\n- List types: name, package, key methods\n- List relationships: \"TypeName implements InterfaceName\"\n- Keep total prompt size reasonable (estimate ~4K tokens for a medium project)\n\n### Wiring in main.go\n\nWhen \\`--enrich\\` is set:\n1. Create \\`llm.Client\\` from env vars\n2. Replace the enricher pipeline with LLM-backed enrichers:\n   \\`\\`\\`go\n   enrichers := []enricher.Enricher{\n       enricher.NewLLMGrouper(llmClient, enricher.NewDefaultGrouper()),\n       enricher.NewLLMSimplifier(llmClient, enricher.NewDefaultSimplifier()),\n   }\n   \\`\\`\\`\n3. Optionally run pattern detection and annotation as separate steps (their results feed into diagram generation, not the Result pipeline)\n\n### Error Handling \u0026 Fallback\n\nEvery LLM enricher wraps a default enricher. On any error:\n1. Log at WARN level with \\`component=enricher\\`, error details, and which enricher failed\n2. Return the default enricher's result\n3. Continue the pipeline — a single enricher failure does not abort the run\n\n### Token Budget\n\nEach enricher prompt is self-contained and focused. For a medium project (20 interfaces, 50 types, 100 relations):\n- Grouper prompt: ~2K tokens input, ~500 tokens output\n- Pattern detector: ~2K tokens input, ~500 tokens output\n- Simplifier: ~1.5K tokens input, ~200 tokens output\n- Annotator: ~2K tokens input, ~1K tokens output\n- Scorer: ~1K tokens input, ~500 tokens output\n\nTotal: ~12K tokens per run. With gpt-4o-mini at $0.15/1M input + $0.60/1M output, this costs ~$0.002 per run.\n\n## Files to Create\n\n1. **\\`internal/enricher/llm/client.go\\`** — LLM HTTP client (OpenAI-compatible chat completions, JSON mode, retries, timeout)\n2. **\\`internal/enricher/llm/serialize.go\\`** — Helper to serialize \\`analyzer.Result\\` into compact prompt text\n3. **\\`internal/enricher/llm/client_test.go\\`** — Unit tests for client with httptest mock server\n4. **\\`internal/enricher/llm_grouper.go\\`** — LLM-backed semantic grouper\n5. **\\`internal/enricher/llm_patterns.go\\`** — LLM-backed pattern detector\n6. **\\`internal/enricher/llm_simplifier.go\\`** — LLM-backed intelligent simplifier\n7. **\\`internal/enricher/llm_annotator.go\\`** — LLM-backed annotator\n8. **\\`internal/enricher/llm_scorer.go\\`** — LLM-backed relationship scorer\n\n## Files to Modify\n\n1. **\\`main.go\\`** — Add \\`--enrich\\` flag, env var reading, conditional LLM enricher pipeline construction\n2. **\\`docs/architecture.md\\`** — Document the LLM enricher subsystem, client abstraction, fallback behavior\n3. **\\`docs/cli-reference.md\\`** — Document \\`--enrich\\` flag and required env vars\n4. **\\`internal/integration_test.go\\`** — Add integration test for LLM enricher pipeline (using mock HTTP server)\n\n## Dependencies\n\n- **No new external Go modules required** — uses stdlib \\`net/http\\` + \\`encoding/json\\` for the LLM client\n- Internal: depends on \\`internal/analyzer\\` (types), \\`internal/enricher\\` (interfaces)\n- External runtime: requires an OpenAI-compatible API endpoint when \\`--enrich\\` is enabled\n\n## Edge Cases \u0026 Error Handling\n\n1. **Missing API key with --enrich**: Print clear error message and exit (fail fast, don't silently fall back)\n2. **LLM returns malformed JSON**: Log warning, fall back to default enricher\n3. **LLM returns valid JSON but missing/extra fields**: Use what's available, ignore extras, fall back for missing\n4. **LLM timeout (default 30s per request)**: Log warning, fall back to default\n5. **LLM returns node keys that don't match any actual node**: Ignore unknown keys, only use valid references\n6. **Empty result (0 interfaces/types)**: Skip LLM calls entirely, return defaults immediately\n7. **Very large projects (\u003e100 types)**: Truncate the prompt by including only the most-connected nodes (pre-filter using edge count before sending to LLM)\n8. **Rate limiting (429)**: Respect Retry-After header, retry once, then fall back\n\n## Testing Strategy\n\n### Unit Tests\n- **\\`internal/enricher/llm/client_test.go\\`**: Test HTTP client against \\`httptest\\` mock server — success, timeout, 5xx retry, malformed response, JSON mode header\n- Each LLM enricher file gets table-driven tests with mock LLM responses (use a mock client interface)\n\n### Integration Tests\n- Add test in \\`internal/integration_test.go\\` that:\n  1. Starts a mock HTTP server returning canned LLM responses\n  2. Creates LLM enrichers pointed at the mock\n  3. Runs the full pipeline on testdata/01_single_iface\n  4. Asserts the enriched result has groups, patterns, annotations, scores\n  5. Tests fallback: mock returns 500, verify default enricher result is used\n\n### Manual Verification\n- Run \\`goifaces --enrich ./testdata/01_single_iface -output test.mmd\\` against a real LLM endpoint\n- Inspect logs for LLM request/response details at DEBUG level\n- Compare diagram output with and without \\`--enrich\\` flag","status":"closed","priority":4,"issue_type":"feature","assignee":"nova","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:44.690964-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-20T18:13:04.262044-06:00","closed_at":"2026-02-20T18:13:04.262044-06:00","close_reason":"Implemented all 5 LLM-backed enrichers with fallback, client abstraction, tests, and documentation"}
{"id":"test-loom-co9","title":"Break large diagrams into paginated slides for readability","description":"Large diagrams like go-memdb produce a single very wide Mermaid chart that's too small to read. Need to split large diagrams into multiple slides/pages. Approach options: (1) Group by interface — each slide shows one interface and its implementors, (2) Group by package — each slide shows one package's types and interfaces, (3) Auto-partition by node count — split when diagram exceeds N nodes. The HTML server should add slide navigation (prev/next/overview). Each slide is a separate Mermaid diagram. An overview slide could show just the relationship graph without method details. Consider also adding a sidebar navigation listing all interfaces/types for quick jumping.","status":"closed","priority":2,"issue_type":"feature","owner":"olesho@gmail.com","created_at":"2026-02-19T16:27:53.624251-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:47:39.028799-06:00","closed_at":"2026-02-19T16:47:39.028799-06:00","close_reason":"Closed"}
{"id":"test-loom-dih","title":"Create project documentation","description":"CLAUDE.md (agent rules), AGENTS.md (agent workflow), docs/architecture.md, docs/cli-reference.md, docs/logging.md, docs/development.md, scripts/visual-verify.sh","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:06:39.4316-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:06:43.273698-06:00","closed_at":"2026-02-19T09:06:43.273698-06:00","close_reason":"All docs and scripts created"}
{"id":"test-loom-dl6","title":"Create integration test suite with 10 testdata scenarios","description":"internal/integration_test.go with 12 subtests across 10 testdata dirs. Each testdata dir is a self-contained Go module. Tests cover: single iface, multi impl, multi iface, pointer receiver, embedded iface, cross-package, stdlib ifaces (with/without), empty iface, unexported (with/without), diamond pattern.","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:06:32.183689-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:06:35.529773-06:00","closed_at":"2026-02-19T09:06:35.529773-06:00","close_reason":"All 12 tests passing. Fixed stdlib module paths, added stdlib package loading, and error builtin handling."}
{"id":"test-loom-f0x","title":"Color-code interfaces vs implementations in Mermaid diagrams","description":"Use Mermaid classDiagram styling (classDef + cssClass) to visually distinguish interfaces from concrete types. For example, interfaces in blue/teal and implementations in green/gray. This makes it immediately obvious which boxes are contracts vs implementations when viewing the diagram. Implementation is in internal/diagram/mermaid.go — add classDef statements after the classDiagram header and apply them to interface vs type nodes.","status":"closed","priority":2,"issue_type":"feature","owner":"olesho@gmail.com","created_at":"2026-02-19T11:43:00.117332-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T12:59:07.123668-06:00","closed_at":"2026-02-19T12:59:07.123668-06:00","close_reason":"Implemented in a20df86. Interfaces blue (#2374ab), implementations green (#4a9c6d) via Mermaid classDef + cssClass."}
{"id":"test-loom-f13","title":"Implement hub-and-spoke slide splitting strategy","description":"Implement the first concrete Splitter strategy: hub-and-spoke.\n\nAlgorithm:\n1. Classify nodes by connection count:\n   - 'Hub' nodes (reusable): interfaces/types with connections \u003e= threshold (e.g., 3+). These appear on EVERY slide as context.\n   - 'Spoke' nodes (non-reusable): implementations with fewer connections. These are chunked into groups.\n\n2. Group spoke nodes into chunks of N (configurable, default 3-4 per slide).\n\n3. For each chunk, build a slide containing:\n   - All hub nodes (the shared interfaces)\n   - The chunk's spoke nodes (implementations)\n   - Only the relations connecting these specific nodes\n\n4. Slide 0 remains the overview (all nodes, no methods).\n\nExample with go-memdb:\n- Hubs: memdb_Indexer, memdb_MultiIndexer, memdb_SingleIndexer, memdb_PrefixIndexer (4+ connections each)\n- Spokes: BoolFieldIndex, CompoundMultiIndex, ConditionalIndex, etc. (3 connections each)\n- Slides: chunks of 3 spokes + all hubs\n\nEdge cases:\n- A node that's both high-connectivity AND an implementation stays as a hub\n- ResultIterator + FilterIterator form their own small cluster — they should be grouped together\n- If total nodes \u003c= threshold, return single slide (no splitting)\n\nDepends on: splitter abstraction task.","status":"closed","priority":1,"issue_type":"feature","owner":"olesho@gmail.com","created_at":"2026-02-19T17:07:23.512936-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T19:19:24.213173-06:00","closed_at":"2026-02-19T19:19:24.213173-06:00","close_reason":"Implemented in hub-and-spoke slide splitting session: split package with Splitter interface, HubAndSpoke strategy, CLI flags, integration tests. All tests + linter pass.","dependencies":[{"issue_id":"test-loom-f13","depends_on_id":"test-loom-wa8","type":"blocks","created_at":"2026-02-19T17:07:38.275703-06:00","created_by":"Oleh Luchkiv"}]}
{"id":"test-loom-ije","title":"Replace dash-dotted arrow lines with solid ones in Mermaid diagrams","design":"## Summary\n\nReplace the Mermaid `..|\u003e` (dashed/dash-dotted realization arrow) with `--|\u003e` (solid inheritance arrow) in all generated class diagrams. Currently, `writeRelation` in `mermaid.go` uses `..|\u003e` which renders as a dashed line in Mermaid. The task asks for solid lines instead, which is `--|\u003e` in Mermaid syntax. This is a cosmetic change affecting diagram output only — no logic or architecture changes.\n\n## Technical Approach\n\nThis is a simple string replacement. In Mermaid classDiagram syntax:\n- `..|\u003e` = dashed line with open arrowhead (UML \"realization\")\n- `--|\u003e` = solid line with open arrowhead (UML \"inheritance\")\n\nThe single source of truth is the `writeRelation` function in `mermaid.go`. All tests that assert on the arrow syntax also need updating.\n\nNo new dependencies, no new patterns, no architectural decisions.\n\n## Files to Modify\n\n### 1. `goifaces/internal/diagram/mermaid.go` (line 188)\nChange the format string in `writeRelation` from `..|\u003e` to `--|\u003e`:\n```go\n// Before:\nline := fmt.Sprintf(\"    %s ..|\u003e %s\", typeID, ifaceID)\n// After:\nline := fmt.Sprintf(\"    %s --|\u003e %s\", typeID, ifaceID)\n```\nThis is the ONLY production code change.\n\n### 2. `goifaces/internal/integration_test.go` (multiple lines)\nUpdate all test assertions and the `normalizeOutput` helper to use `--|\u003e` instead of `..|\u003e`:\n\n**`normalizeOutput` function (line 82):** Change the relation-detection string:\n```go\n// Before:\n} else if strings.Contains(trimmed, \"..|\u003e\") {\n// After:\n} else if strings.Contains(trimmed, \"--|\u003e\") {\n```\n\n**All `assert.Contains` / `assert.NotContains` calls** that check for `..|\u003e` relations (lines 141, 153, 154, 170-176, 186, 199-201, 211, 236, 249, 260, 276-278, 291-293). Each `..|\u003e` becomes `--|\u003e`. Full list:\n- Line 141: `shapes_Circle ..|\u003e shapes_Shape` → `shapes_Circle --|\u003e shapes_Shape`\n- Line 153: `animals_Dog ..|\u003e animals_Speaker` → `animals_Dog --|\u003e animals_Speaker`\n- Line 154: `animals_Cat ..|\u003e animals_Speaker` → `animals_Cat --|\u003e animals_Speaker`\n- Line 170: `store_MemStore ..|\u003e store_Reader` → `store_MemStore --|\u003e store_Reader`\n- Line 171: `store_MemStore ..|\u003e store_Writer` → `store_MemStore --|\u003e store_Writer`\n- Line 172: `store_MemStore ..|\u003e store_ReadWriter` → `store_MemStore --|\u003e store_ReadWriter`\n- Line 174: `store_ReadOnlyCache ..|\u003e store_Reader` → `store_ReadOnlyCache --|\u003e store_Reader`\n- Line 175: `store_ReadOnlyCache ..|\u003e store_Writer` → `store_ReadOnlyCache --|\u003e store_Writer`\n- Line 176: `store_ReadOnlyCache ..|\u003e store_ReadWriter` → `store_ReadOnlyCache --|\u003e store_ReadWriter`\n- Line 186: `db_Connection ..|\u003e db_Closer` → `db_Connection --|\u003e db_Closer`\n- Line 199: `io2_MyFile ..|\u003e io2_Reader` → `io2_MyFile --|\u003e io2_Reader`\n- Line 200: `io2_MyFile ..|\u003e io2_Closer` → `io2_MyFile --|\u003e io2_Closer`\n- Line 201: `io2_MyFile ..|\u003e io2_ReadCloser` → `io2_MyFile --|\u003e io2_ReadCloser`\n- Line 211: `impl_ConsoleLogger ..|\u003e ifaces_Logger` → `impl_ConsoleLogger --|\u003e ifaces_Logger`\n- Line 236: `assert.NotContains(t, normalized, \"..|\u003e\")` → `assert.NotContains(t, normalized, \"--|\u003e\")`\n- Line 249: `assert.NotContains(t, normalized, \"..|\u003e\")` → `assert.NotContains(t, normalized, \"--|\u003e\")`\n- Line 260: `internal_Cat ..|\u003e internal_Runner` → `internal_Cat --|\u003e internal_Runner`\n- Line 276: `internal_dog ..|\u003e internal_walker` → `internal_dog --|\u003e internal_walker`\n- Line 277: `internal_dog ..|\u003e internal_Runner` → `internal_dog --|\u003e internal_Runner`\n- Line 278: `internal_Cat ..|\u003e internal_Runner` → `internal_Cat --|\u003e internal_Runner`\n- Line 291: `diamond_DB ..|\u003e diamond_Saver` → `diamond_DB --|\u003e diamond_Saver`\n- Line 292: `diamond_DB ..|\u003e diamond_Loader` → `diamond_DB --|\u003e diamond_Loader`\n- Line 293: `diamond_DB ..|\u003e diamond_Persister` → `diamond_DB --|\u003e diamond_Persister`\n\n## Files to Create\nNone.\n\n## Dependencies\nNone. No external packages needed. This is a pure string replacement.\n\n## Edge Cases \u0026 Error Handling\n- No edge cases — this is a deterministic string replacement with no conditional logic.\n- The `normalizeOutput` test helper in `integration_test.go` uses `..|\u003e` to detect relation lines during parsing. This MUST be updated to `--|\u003e` or the test normalizer will silently skip relation lines, causing false test passes.\n\n## Testing Strategy\n1. Run the full test suite: `cd goifaces \u0026\u0026 go test ./...`\n2. All 11 end-to-end test cases plus the hub-and-spoke slide test should pass.\n3. Manually verify by running the tool on any testdata directory and inspecting the output contains `--|\u003e` (solid arrows) instead of `..|\u003e` (dashed arrows).","notes":"BLOCKED: Source code files do not exist in the repository. The design references goifaces/internal/diagram/mermaid.go and goifaces/internal/integration_test.go, but the repo only contains the initial commit with .beads/issues.jsonl and AGENTS.md. All branches (main, nova, falcon, spark) point to the same initial commit. The goifaces project code was never committed to this repository. Cannot modify files that don't exist.","status":"closed","priority":2,"issue_type":"task","assignee":"nova","owner":"olesho@gmail.com","created_at":"2026-02-20T05:02:17.855914-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-20T13:17:06.228321-06:00","closed_at":"2026-02-20T13:17:06.228321-06:00","close_reason":"Replaced ..|\u003e with --|\u003e in mermaid.go and all test assertions"}
{"id":"test-loom-izp","title":"Wire splitter into main pipeline and test with go-memdb","description":"Wire the hub-and-spoke splitter into main.go and ServeSlides. Verify with go-memdb that:\n1. Overview slide shows all 17 nodes with no methods\n2. Each detail slide shows 3-4 implementations + the shared interfaces they connect to\n3. All relations are preserved (no missing arrows)\n4. Slides are navigable via prev/next/picker\n5. Each slide's Mermaid validates via scripts/verify-mermaid.sh\n\nAdd integration test: build slides for go-memdb-like synthetic data, assert slide count and hub presence on each slide.\n\nDepends on: hub-and-spoke implementation task.","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T17:07:28.151922-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T19:19:24.215067-06:00","closed_at":"2026-02-19T19:19:24.215067-06:00","close_reason":"Implemented in hub-and-spoke slide splitting session: split package with Splitter interface, HubAndSpoke strategy, CLI flags, integration tests. All tests + linter pass.","dependencies":[{"issue_id":"test-loom-izp","depends_on_id":"test-loom-f13","type":"blocks","created_at":"2026-02-19T17:07:38.349872-06:00","created_by":"Oleh Luchkiv"}]}
{"id":"test-loom-jzu","title":"Show file paths in Mermaid diagram blocks for interfaces and implementations","description":"Add source file path information to each class block in the generated Mermaid diagram. Both interface and implementation blocks should display the file path where they are defined. This requires: (1) capturing file position during analysis in analyzer.go (using go/packages token position info), (2) storing file path in InterfaceDef and TypeDef structs in types.go, (3) rendering the file path in the Mermaid class block in mermaid.go (e.g. as a note or first line in the block). The file path should be relative to the analyzed module root for readability.","status":"closed","priority":2,"issue_type":"feature","owner":"olesho@gmail.com","created_at":"2026-02-19T16:24:30.267171-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:43:48.378403-06:00","closed_at":"2026-02-19T16:43:48.378403-06:00","close_reason":"Closed"}
{"id":"test-loom-mce","title":"Smoke test goifaces against real Go repositories","description":"Test the binary against real repos: 1) ./goifaces https://github.com/hashicorp/go-memdb 2) ./goifaces on the goifaces project itself 3) A large repo to stress-test. Verify diagrams render correctly, logs are valid JSONL, and edge cases (compile errors, missing deps) produce warnings not crashes.","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:41.428593-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:48:48.592292-06:00","closed_at":"2026-02-19T16:48:48.592292-06:00","close_reason":"Closed"}
{"id":"test-loom-php","title":"Remove orphaned interfaces from chart slides","description":"Each generated slide might contain orphaned interfaces - those which don't have any implementation (struct/type) related to them on that slide. Remove such interfaces from the chart. This logic should be applied per-slide: if an interface has no implementing type on a given slide, it should be excluded from that slide's Mermaid diagram.","design":"## Summary\n\nWhen slides are split using the HubAndSpoke strategy, hub interfaces are replicated onto EVERY detail slide. However, on any given slide, some of these hub interfaces may have no implementing type (spoke) present. For example, if PrefixIndexer is a hub interface connected to 4 types, but a slide only contains 3 types that don't implement PrefixIndexer, then PrefixIndexer appears as an orphaned node with no arrows. This task removes such per-slide orphaned interfaces so each detail slide only shows interfaces that have at least one implementing type on that slide.\n\n## Technical Approach\n\n**Where to apply the fix:** In `subResultForSplitGroup()` in `internal/diagram/slides.go`.\n\nThis function already correctly filters relations to only those where both the interface AND type are present in the group. The problem is that `sub.Interfaces` includes ALL interfaces from the group's `HubKeys`, even if none of their relations survived the relation filter. The fix is a post-filter step: after collecting relations, build a set of interface keys that participate in at least one relation, then trim `sub.Interfaces` to only those.\n\n**Why this location:** The splitter's job is node classification (hub vs spoke). The `subResultForSplitGroup` function is responsible for producing the final per-slide Result. Filtering orphans at this stage is clean, doesn't change the splitter contract, and naturally applies only to detail slides (the overview slide and full diagram slide don't go through this function).\n\n**Why NOT touch the splitter:** Hub interfaces should remain in every group's HubKeys for the splitter's correctness — they may have relations on some slides but not others. Removing them from HubKeys would break the splitter abstraction. The filtering belongs at the Result-assembly level.\n\n**Trade-off:** An interface might appear on zero detail slides if it's a hub but all its implementing types happen to share slides with other types. This is acceptable — the interface still appears on the overview slide, and showing it on a detail slide with no connections would be confusing.\n\n## Files to Modify\n\n### 1. `goifaces/internal/diagram/slides.go`\n**Function: `subResultForSplitGroup()`** (lines 66-106)\n\nAfter the existing relation-filtering loop (lines 97-103), add a post-filter step:\n1. Build a set of interface keys that appear in at least one relation in `sub.Relations`\n2. Filter `sub.Interfaces` to only those whose key is in that set\n\nPseudocode:\n```go\n// After the existing relation loop...\n\n// Post-filter: remove interfaces with no relations on this slide\nusedIfaces := make(map[string]bool)\nfor _, rel := range sub.Relations {\n    ik := typeKey(rel.Interface.PkgPath, rel.Interface.Name)\n    usedIfaces[ik] = true\n}\nvar filteredIfaces []analyzer.InterfaceDef\nfor _, iface := range sub.Interfaces {\n    ik := typeKey(iface.PkgPath, iface.Name)\n    if usedIfaces[ik] {\n        filteredIfaces = append(filteredIfaces, iface)\n    }\n}\nsub.Interfaces = filteredIfaces\n```\n\nThis is ~10 lines of straightforward Go. No new functions needed.\n\n## Files to Create\n\nNone.\n\n## Dependencies\n\nNo external packages needed. This uses only existing data structures and patterns.\n\n## Edge Cases \u0026 Error Handling\n\n1. **Interface on zero detail slides:** If a hub interface's implementing types all cluster onto slides where they share other hubs, the interface may not appear on any detail slide. This is correct — it still shows on the overview slide.\n\n2. **Non-hub interfaces:** These are attached to chunks based on their connected types, so they should always have at least one relation on their slide. The post-filter handles the edge case where this invariant breaks (e.g., if the attachment logic has a bug).\n\n3. **Empty sub.Relations:** If a group has no surviving relations (unusual but possible), all interfaces get filtered out, leaving an empty diagram. This is correct behavior — an empty slide would be pruned or show only type blocks.\n\n4. **Overview slide:** Not affected — `generateOverviewMermaid()` is called directly on the full result, not through `subResultForSplitGroup()`.\n\n5. **Full diagram (single-slide mode):** Not affected — uses `GenerateMermaid()` directly on the full filtered result.\n\n## Testing Strategy\n\n### Update existing test\n**`TestHubAndSpokeSlides` in `internal/integration_test.go`** (lines 322-439):\nThe current test asserts all 4 hub interfaces appear on EVERY detail slide. After the fix, only hubs with implementing types on that slide should appear. Update the test to:\n- Instead of asserting all hubs on all slides, verify that each hub appears only on slides where it has at least one connected type\n- PrefixIndexer connects to: StringFieldIndex, StringMapFieldIndex, StringSliceFieldIndex, CompoundIndex — should only appear on slides containing these types\n- ResultIterator connects to: FilterIterator — should only appear on the slide containing FilterIterator\n- Indexer, MultiIndexer, SingleIndexer connect to all 11 field index types — should appear on all slides except the one with only FilterIterator (if such a slide exists)\n\n### Add new targeted test\nAdd a test `TestOrphanedInterfacesRemovedFromSlides` in `internal/integration_test.go` that:\n1. Creates a synthetic result with 2 hub interfaces (A connects to X,Y,Z; B connects to only Z)\n2. Splits into groups where X,Y are on slide 1 and Z is on slide 2\n3. Asserts: slide 1 contains hub A but NOT hub B (B is orphaned on slide 1)\n4. Asserts: slide 2 contains both hub A and hub B\n\n### Visual verification\nRun `bash scripts/visual-verify.sh` after implementation to confirm SVG output looks clean.\n\n### Manual verification\nRun the tool against a real Go repo (e.g., go-memdb) and visually inspect that detail slides no longer show disconnected interface nodes.","status":"review","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-21T08:09:56.652447-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-21T08:13:41.797827-06:00"}
{"id":"test-loom-snp","title":"Scaffold goifaces project structure","description":"go mod init, directory structure, .golangci.yml, .githooks/pre-commit, .gitignore, git init with custom hooks path","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:22.110035-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:05:26.501622-06:00","closed_at":"2026-02-19T09:05:26.501622-06:00","close_reason":"Project scaffolded with all dirs, configs, and git hooks"}
{"id":"test-loom-vnu","title":"Implement main.go CLI entry point","description":"main.go - flag parsing (path, port, filter, include-stdlib, include-unexported, output, no-browser, log-file, log-level), pipeline orchestration, signal handling","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:06:24.159055-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:06:27.84161-06:00","closed_at":"2026-02-19T09:06:27.84161-06:00","close_reason":"Full pipeline wired: resolve → analyze → filter → enrich → diagram → serve/write"}
{"id":"test-loom-wa8","title":"Design splitter abstraction as a decoupled module","description":"Create a Splitter interface in internal/diagram/split/ (new subpackage) that takes an *analyzer.Result and returns []Slide. The interface should be strategy-based so we can swap different splitting algorithms without touching the rest of the codebase.\n\nKey design:\n- type Splitter interface { Split(result *analyzer.Result, opts SplitOptions) []Slide }\n- SplitOptions carries config: max implementations per slide, min connections to be 'reusable', etc.\n- The existing BuildSlides() in slides.go becomes a thin wrapper that delegates to a Splitter\n- Splitters are composed in main.go, not hardcoded\n\nThis is the abstraction layer only — no concrete strategy implementation.","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T17:07:15.357225-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T19:19:24.209267-06:00","closed_at":"2026-02-19T19:19:24.209267-06:00","close_reason":"Implemented in hub-and-spoke slide splitting session: split package with Splitter interface, HubAndSpoke strategy, CLI flags, integration tests. All tests + linter pass."}
{"id":"test-loom-xf7","title":"Remove method names from implementation blocks in Mermaid diagrams","description":"Remove method names from implementation (green) blocks in Mermaid class diagrams. Methods are already shown in interface blocks, so impl blocks should only display the struct name. This reduces visual clutter especially for large repos like go-memdb.\n\nChanges needed:\n1. internal/diagram/mermaid.go - writeTypeBlock: stop writing method lines, just emit class name + source file comment. Remove now-unused buildRelevantMethodsMap function. Remove relevantSet passing from GenerateMermaid.\n2. internal/diagram/slides.go - generateOverviewMermaid: add 'direction LR' after classDiagram (was missed in previous LR change).\n3. internal/integration_test.go - TestHubAndSpokeSlides overview assertion (line 422) checks no '+' lines — still valid. Detail slide assertions are fine since methods come from interface blocks.\n4. Run go test ./..., golangci-lint run ./..., bash scripts/visual-verify.sh (rebuild binary first with go build -o goifaces .)\n5. Update docs/architecture.md to note impl blocks show only type names.\n\nNOTE: mermaid.go already has partial edits applied (buildRelevantMethodsMap removed, writeTypeBlock simplified, relevantSet removed from GenerateMermaid call). Verify the current state and complete any remaining work.","design":"## Summary\n\nThis task removes method names from implementation (green) blocks in Mermaid class diagrams. Methods are already shown in interface (blue) blocks, so repeating them in impl blocks is redundant visual clutter — especially for large repos like go-memdb with many implementations. The task also ensures slides.go has 'direction LR' in the overview diagram, and updates architecture documentation.\n\n**NOTE: The code changes described in the task description have already been applied to the codebase.** The implementing agent's primary job is to VERIFY the current state is correct and run the full validation pipeline (tests, lint, visual-verify).\n\n## Technical Approach\n\nThe approach is straightforward: `writeTypeBlock` in mermaid.go was simplified to only emit the struct name and source file comment — no method lines. The `buildRelevantMethodsMap` function (which built a lookup of methods to display on type blocks) was removed as it's no longer needed. The `relevantSet` parameter was removed from `GenerateMermaid`'s call chain.\n\nThis is safe because:\n- Interface blocks already display all method signatures with `+MethodName()` syntax\n- Relation arrows (`Type ..|\u003e Interface`) clearly show which types implement which interfaces\n- Removing duplicate method listings significantly declutters diagrams for repos with many implementations\n\n## Files to Create\n\nNone.\n\n## Files to Modify\n\nAll changes below appear to be ALREADY APPLIED. The implementing agent should verify each one:\n\n### 1. `internal/diagram/mermaid.go`\n**Verify current state:**\n- `writeTypeBlock` (lines 158-165): Should only write `class ID { }` with an optional `%% file:` comment. Should NOT call `writeMethodLines` or emit any `+MethodName()` lines.\n- `buildRelevantMethodsMap`: Should NOT exist anywhere in the file.\n- `GenerateMermaid` (line 23): Should NOT accept or pass a `relevantSet` parameter. The call to `writeTypeBlock` on line 84 should take only `(\u0026b, typ)`.\n- `writeMethodLines` should only be called from `writeInterfaceBlock` (line 151).\n\n**If any of the above are NOT already applied:** Apply the missing changes per the task description.\n\n### 2. `internal/diagram/slides.go`\n**Verify current state:**\n- `generateOverviewMermaid` should have `direction LR` after `classDiagram` (currently line 154).\n- Type blocks in the overview should be empty (no methods), which they already are by design of this function.\n\n### 3. `internal/integration_test.go`\n**Verify current state:**\n- Line 422: `assert.NotContains(t, overview, \"+\", \"overview should have no method lines\")` — this assertion validates overview has no method `+` lines. Should remain as-is.\n- All other test assertions check for method names like `Area()` in the full diagram output. These will still pass because methods appear in interface blocks (via `writeInterfaceBlock` → `writeMethodLines`).\n- No test changes needed.\n\n### 4. `docs/architecture.md`\n**Verify current state:**\n- Line 51 should contain text explaining that implementation blocks show only the type name and methods are omitted. Currently reads: \"implementation blocks (green) show only the type name -- methods are omitted from impl blocks because they are already listed in the interface blocks, reducing visual clutter.\"\n\n## Dependencies\n\n- No external packages needed\n- No internal module changes needed\n- No blocking tasks\n\n## Edge Cases \u0026 Error Handling\n\n1. **Types with no SourceFile:** `writeTypeBlock` handles this — the `%% file:` comment is conditional on `typ.SourceFile != \"\"`. Verify this still works.\n2. **Overview vs detail slides:** Overview diagrams (slides.go) already omit methods from both interface AND type blocks. Detail slides show methods only in interface blocks. Verify both render correctly.\n3. **Empty diagrams:** Tests 07 (no stdlib) and 08 (empty iface) produce empty diagrams — verify they still pass.\n\n## Testing Strategy\n\n### Automated Tests\nRun: `cd /Users/olehluchkiv/Work/test-loom/goifaces \u0026\u0026 go test ./...`\n\nKey tests to verify pass:\n- `TestEndToEnd` — all 11 subtests, especially:\n  - `01_single_iface`: confirms `Area()` still appears (in interface block)\n  - `11_source_file_path`: confirms `%% file:` comments still appear\n- `TestHubAndSpokeSlides` — especially line 422 assertion that overview has no `+` method lines\n\n### Lint\nRun: `cd /Users/olehluchkiv/Work/test-loom/goifaces \u0026\u0026 golangci-lint run ./...`\n\n### Visual Verification\nRun:\n```bash\ncd /Users/olehluchkiv/Work/test-loom/goifaces\ngo build -o goifaces .\nbash scripts/visual-verify.sh\n```\nThen read a few output SVGs (e.g., `testdata/01_single_iface/output.svg`, `testdata/03_multi_iface/output.svg`) to visually confirm:\n- Interface blocks (blue) show method signatures\n- Implementation blocks (green) show ONLY the type name (no methods)\n- Relation arrows are intact\n\n### Manual Spot-Check\nAfter visual-verify, read the raw `.mmd` output for `testdata/01_single_iface/output.mmd` and verify:\n- The Shape interface block contains `+Area()` \n- The Circle impl block does NOT contain `+Area()` — only the class name and `%% file:` comment","status":"closed","priority":2,"issue_type":"task","assignee":"spark","owner":"olesho@gmail.com","created_at":"2026-02-20T04:56:36.227111-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-20T13:16:25.010019-06:00","closed_at":"2026-02-20T13:16:25.010019-06:00","close_reason":"Verified all code changes already applied. Tests pass, lint clean, visual-verify correct. Code review: no issues."}
{"id":"test-loom-xp4","title":"Support flags after positional arguments in CLI","description":"Go's flag package stops parsing at the first non-flag argument, so 'goifaces ./path -output file.md' doesn't work — flags must come before the positional arg. Consider switching to pflag or manually parsing args to support both orderings.","status":"closed","priority":3,"issue_type":"bug","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:42.944588-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T11:04:29.439666-06:00","closed_at":"2026-02-19T11:04:29.439666-06:00","close_reason":"Fixed in 045b6fb. Added reorderArgs() to support flags in any position."}
{"id":"test-loom-ymy","title":"Remote repo cloning fails to resolve Go module - packages not loaded","description":"When analyzing a remote GitHub repo (e.g. https://github.com/vxcontrol/pentagi), the tool clones successfully but fails at go mod download with 'no modules specified' and package loading fails with 'directory prefix . does not contain main module'. The tool likely isn't setting the working directory to the cloned repo path before running Go commands. Repro: ./goifaces https://github.com/vxcontrol/pentagi -port 8084","design":"## Summary\n\nWhen goifaces receives a remote GitHub URL, cloneRepo() clones the repo to a temp directory and returns that directory directly. For repos where go.mod is in a subdirectory (e.g. pentagi has go.mod at backend/), the returned directory has no go.mod, causing go mod download to fail with 'no modules specified' and packages.Load to fail with 'directory prefix . does not contain main module'. The fix: after cloning, search the cloned tree for go.mod and return the module root, mirroring how the local path handler already works.\n\n## Technical Approach\n\nThe local path handler (resolver.go lines 37-50) already correctly calls findModuleRoot(absPath) which walks UP parent directories to find go.mod. For cloned repos, we need to walk DOWN from the repo root since go.mod may be in a subdirectory.\n\n**Approach**: Add a new findModuleRootInTree() function that searches downward through the cloned repo for go.mod files. Then update cloneRepo() to call it after cloning, before running go mod download. This mirrors the existing pattern in the local path handler.\n\n**Key design decisions**:\n- Search downward (breadth-first) to find the shallowest go.mod, which is most likely the primary module\n- Skip vendor/ and .git/ directories during the search\n- If go.mod is at the repo root, this is a no-op (same as current behavior)\n- If multiple go.mod files exist at different depths, pick the shallowest one\n- If multiple go.mod files exist at the SAME depth, log a warning and pick the first one found (alphabetically sorted for determinism)\n\n## Files to Modify\n\n### 1. goifaces/internal/resolver/resolver.go\n\n**Changes needed in cloneRepo() (lines 58-84):**\n- After the git clone succeeds (line 77), call a new findModuleRootInTree(tmpDir) function\n- Use the returned module root path for goModDownload() instead of tmpDir\n- Return the module root path instead of tmpDir\n- Keep tmpDir for the cleanup function (we still want to clean the whole clone)\n\nThe updated cloneRepo() should look like:\n```go\nfunc cloneRepo(ctx context.Context, url string, logger *slog.Logger) (string, func(), error) {\n    tmpDir, err := os.MkdirTemp(\"\", \"goifaces-clone-*\")\n    if err != nil {\n        return \"\", func() {}, fmt.Errorf(\"creating temp dir: %w\", err)\n    }\n\n    cleanup := func() {\n        _ = os.RemoveAll(tmpDir)\n    }\n\n    logger.Info(\"cloning repository\", \"url\", url, \"dest\", tmpDir)\n\n    cmd := exec.CommandContext(ctx, \"git\", \"clone\", \"--depth=1\", url, tmpDir)\n    cmd.Stderr = os.Stderr\n    if err := cmd.Run(); err != nil {\n        cleanup()\n        return \"\", func() {}, fmt.Errorf(\"git clone: %w\", err)\n    }\n\n    logger.Info(\"clone complete\", \"dest\", tmpDir)\n\n    // Find module root (go.mod) in the cloned tree\n    modRoot, err := findModuleRootInTree(tmpDir)\n    if err != nil {\n        cleanup()\n        return \"\", func() {}, fmt.Errorf(\"finding module root in cloned repo: %w\", err)\n    }\n\n    logger.Info(\"found module root\", \"module_root\", modRoot)\n\n    if err := goModDownload(ctx, modRoot, logger); err != nil {\n        logger.Warn(\"go mod download failed\", \"error\", err)\n    }\n\n    return modRoot, cleanup, nil\n}\n```\n\n**New function findModuleRootInTree():**\nAdd this function after the existing findModuleRoot() function. It does a breadth-first search of the directory tree looking for go.mod files:\n\n```go\n// findModuleRootInTree searches downward from root for the shallowest go.mod file.\n// This is used for cloned repos where go.mod may be in a subdirectory.\nfunc findModuleRootInTree(root string) (string, error) {\n    // First check the root itself (most common case)\n    if _, err := os.Stat(filepath.Join(root, \"go.mod\")); err == nil {\n        return root, nil\n    }\n\n    // BFS through subdirectories to find the shallowest go.mod\n    queue := []string{root}\n    for len(queue) \u003e 0 {\n        var nextLevel []string\n        var candidates []string\n\n        for _, dir := range queue {\n            entries, err := os.ReadDir(dir)\n            if err != nil {\n                continue\n            }\n            for _, entry := range entries {\n                if !entry.IsDir() {\n                    continue\n                }\n                name := entry.Name()\n                // Skip non-module directories\n                if name == \".git\" || name == \"vendor\" || name == \"node_modules\" || name[0] == '.' {\n                    continue\n                }\n                subdir := filepath.Join(dir, name)\n                if _, err := os.Stat(filepath.Join(subdir, \"go.mod\")); err == nil {\n                    candidates = append(candidates, subdir)\n                } else {\n                    nextLevel = append(nextLevel, subdir)\n                }\n            }\n        }\n\n        if len(candidates) \u003e 0 {\n            sort.Strings(candidates)\n            return candidates[0], nil\n        }\n        queue = nextLevel\n    }\n\n    return \"\", fmt.Errorf(\"no go.mod found in %s or any subdirectory\", root)\n}\n```\n\nNote: The sort import is already present in resolver.go (line 10 currently has strings; we need to add \"sort\").\n\nWait, checking the imports: the file has \"strings\" but not \"sort\". We need to add \"sort\" to the imports.\n\n## Files to Create\n\nNone.\n\n## Dependencies\n\n- No new external packages needed\n- \"sort\" from stdlib needs to be added to imports in resolver.go\n\n## Edge Cases \u0026 Error Handling\n\n1. **go.mod at repo root** (most common case): findModuleRootInTree checks root first, returning immediately. Zero behavior change.\n2. **go.mod in a subdirectory** (the bug case): BFS finds the shallowest go.mod and returns its directory.\n3. **Multiple go.mod at same depth**: Sort alphabetically and pick the first. Log a warning. This is a rare edge case but provides deterministic behavior.\n4. **No go.mod anywhere**: Return a clear error message. This handles repos that aren't Go projects.\n5. **Symlinks in repo**: os.ReadDir doesn't follow symlinks by default, which is the safe behavior for cloned repos.\n6. **Very deep directory trees**: BFS naturally handles this; the shallowest module is found first.\n7. **Hidden directories** (starting with .): Skipped to avoid searching .git and similar.\n\n## Testing Strategy\n\n### Unit Tests (add to resolver_test.go or a new file)\n\n1. **Test findModuleRootInTree with go.mod at root**: Create temp dir with go.mod at root, verify it returns root.\n2. **Test findModuleRootInTree with go.mod in subdirectory**: Create temp dir with go.mod in subdir/go.mod, verify it returns subdir path.\n3. **Test findModuleRootInTree with no go.mod**: Create empty temp dir, verify it returns error.\n4. **Test findModuleRootInTree skips .git**: Create temp dir with .git/go.mod and real/go.mod, verify it returns real/.\n5. **Test findModuleRootInTree picks shallowest**: Create temp dir with a/go.mod and a/b/go.mod, verify it returns a/.\n\n### Manual Verification\n\n1. Test with a repo that has go.mod at root: `./goifaces https://github.com/some/simple-go-repo`\n2. Test with pentagi (the original failing case): `./goifaces https://github.com/vxcontrol/pentagi`\n3. Test with a local directory (regression): `./goifaces .`","status":"closed","priority":1,"issue_type":"bug","assignee":"falcon","owner":"olesho@gmail.com","created_at":"2026-02-20T16:30:51.025652-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-21T08:05:31.829556-06:00","closed_at":"2026-02-21T08:05:31.829556-06:00","close_reason":"Replaced shallow depth-1 findModuleRootRecursive with proper BFS that searches all subdirectory levels, skips .git/vendor/node_modules/hidden dirs, and sorts candidates for determinism. Added 6 unit tests."}
{"id":"test-loom-z87","title":"Slide threshold prevents splitting for go-memdb (17 nodes \u003c 20)","description":"go-memdb has 5 interfaces + 12 types = 17 nodes. The default slide threshold is 20, so BuildSlides returns a single Full Diagram slide and never invokes the splitter. The threshold should account for relation density, not just node count. A graph with 17 nodes and 38 relations is highly connected and benefits from splitting.","status":"closed","priority":1,"issue_type":"bug","owner":"olesho@gmail.com","created_at":"2026-02-19T19:29:55.026577-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T19:31:45.835999-06:00","closed_at":"2026-02-19T19:31:45.835999-06:00","close_reason":"Fixed threshold check to also split when relation count \u003e= threshold. go-memdb (17 nodes, 38 relations) now produces 5 slides."}
