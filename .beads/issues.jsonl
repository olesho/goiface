{"id":"test-loom-27c","title":"Implement enricher pipeline with pluggable interfaces","description":"internal/enricher/ - Enricher interface + 5 implementations: grouper (by package), patterns (no-op), simplifier (prune+cap), annotator (no-op), scorer (equal weight). All have LLM-ready interfaces for iteration 2.","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:56.360211-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:06:00.702199-06:00","closed_at":"2026-02-19T09:06:00.702199-06:00","close_reason":"All 5 enricher files implemented with default code-only implementations"}
{"id":"test-loom-2ul","title":"Fix color differentiation not rendering in browser for interfaces vs implementations","description":"The classDef and cssClass directives for color-coding interfaces (blue #2374ab) vs implementations (green #4a9c6d) are present in the generated Mermaid source but not rendering visually in the browser. The styles were added in mermaid.go but may not be taking effect with Mermaid.js v11 in-browser rendering. Need to investigate why and fix.","status":"closed","priority":1,"issue_type":"bug","owner":"olesho@gmail.com","created_at":"2026-02-19T16:25:51.602997-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:43:48.291601-06:00","closed_at":"2026-02-19T16:43:48.291601-06:00","close_reason":"Closed"}
{"id":"test-loom-2xn","title":"Show repository address in webpage title","description":"Add the repository address (local path or GitHub URL) to the HTML page title when serving diagrams via the web UI.","design":"## Summary\n\nThe browser tab currently shows a hardcoded title \\\"goifaces — Interface Diagram (Slides)\\\" regardless of which repository is being analyzed. This task threads the original user input (local path or GitHub URL) through the call chain so it appears in the HTML `\u003ctitle\u003e` tag and `\u003ch1\u003e` heading, giving users immediate context about which repository they're viewing.\n\n## Technical Approach\n\n**Strategy**: Pass the original `input` string from `main.go` through to the server functions as a new `repoAddr` parameter. Use Go template variables to inject it into the HTML `\u003ctitle\u003e` and `\u003ch1\u003e` tags.\n\n**Display format**: \\\"goifaces — \u003crepo-address\u003e\\\" where `\u003crepo-address\u003e` is:\n- The GitHub URL as-is (e.g. \\\"https://github.com/user/repo\\\") for remote repos\n- The resolved absolute path (e.g. \\\"/Users/x/project\\\") for local repos\n\n**Why this approach**: Minimal changes, no new types/abstractions needed. The `input` string is already available in `main.go` — it just needs to be forwarded. Using the raw input preserves what the user typed, which is the most recognizable identifier for them.\n\n**Trade-off considered**: We could shorten the display (e.g. just \\\"user/repo\\\" for GitHub, or basename for local paths) but the full address is more unambiguous and the `\u003ctitle\u003e` tag has no practical length limit.\n\n## Files to Modify\n\n### 1. `goifaces/internal/server/server.go`\n\n**Changes:**\n\na) Add a `RepoTitle` field to the anonymous struct in `Serve()` (line 219):\n```go\ndata := struct {\n    MermaidContent string\n    MermaidRaw     string\n    RepoTitle      string\n}{\n    MermaidContent: mermaidContent,\n    MermaidRaw:     mermaidContent,\n    RepoTitle:      repoTitle,\n}\n```\n\nb) Add a `RepoTitle` field to `slidesData` struct (line 306):\n```go\ntype slidesData struct {\n    Slides     []slideEntry\n    SlideCount int\n    RepoTitle  string\n}\n```\n\nc) Update `Serve` function signature (line 213) to accept `repoTitle string`:\n```go\nfunc Serve(ctx context.Context, mermaidContent string, port int, openBrowser bool, repoTitle string, logger *slog.Logger) error\n```\n\nd) Update `ServeSlides` function signature (line 599) to accept `repoTitle string`:\n```go\nfunc ServeSlides(ctx context.Context, slides []diagram.Slide, port int, openBrowser bool, repoTitle string, logger *slog.Logger) error\n```\n\ne) In `ServeSlides`, pass `repoTitle` into `slidesData` (around line 614):\n```go\ndata := slidesData{\n    Slides:     entries,\n    SlideCount: len(slides),\n    RepoTitle:  repoTitle,\n}\n```\n\nf) Update `htmlTemplate` — change the `\u003ctitle\u003e` (line 23) and `\u003ch1\u003e` (line 139):\n```html\n\u003ctitle\u003egoifaces — {{.RepoTitle}}\u003c/title\u003e\n...\n\u003ch1\u003egoifaces — {{.RepoTitle}}\u003c/h1\u003e\n```\n\ng) Update `slidesHTMLTemplate` — change the `\u003ctitle\u003e` (line 316) and `\u003ch1\u003e` (line 458):\n```html\n\u003ctitle\u003egoifaces — {{.RepoTitle}}\u003c/title\u003e\n...\n\u003ch1\u003egoifaces — {{.RepoTitle}}\u003c/h1\u003e\n```\n\n### 2. `goifaces/main.go`\n\n**Changes:**\n\na) Update the `server.ServeSlides` call (line 159) to pass `input`:\n```go\nif err := server.ServeSlides(ctx, slides, *port, openBrowser, input, logger); err != nil {\n```\n\nNote: The `Serve()` function is currently unused by main (only `ServeSlides` is called in the else branch on line 159), but its signature should still be updated for consistency.\n\n## Files to Create\n\nNone.\n\n## Dependencies\n\nNo external packages needed. Only uses Go standard library (`html/template` handles escaping automatically for `{{.RepoTitle}}`).\n\n## Edge Cases \u0026 Error Handling\n\n1. **HTML injection**: Go's `html/template` auto-escapes template variables, so special characters in paths (e.g. `\u003c`, `\u003e`, `\u0026`, quotes) are safely handled.\n2. **Very long paths**: Local absolute paths can be long. This is acceptable — browser tabs truncate long titles naturally.\n3. **Empty input**: Cannot happen — `main.go` exits with usage error if `input` is empty (line 57-61).\n4. **GitHub URL with query params or fragments**: Displayed as-is, which is fine since the user typed it.\n\n## Testing Strategy\n\n1. **Unit tests**: No existing server tests exist. This change is primarily UI/template-level. The implementation agent should verify the template still parses correctly by ensuring existing integration tests pass (`go test ./...`).\n2. **Manual verification**: Run `goifaces ./some-local-path` and check the browser tab title shows the path. Run with a GitHub URL and verify it shows the URL.\n3. **Lint check**: Run `golangci-lint run ./...` to ensure code quality.\n\n## Documentation Updates\n\n- Update `docs/architecture.md` if it mentions the server functions' signatures.\n- No CLI flag changes, so `docs/cli-reference.md` doesn't need updating.","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-21T15:16:54.118313-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-21T15:21:38.183528-06:00","closed_at":"2026-02-21T15:21:38.183528-06:00","close_reason":"Added repoAddress parameter to Serve and ServeSlides functions, updated HTML templates to show repo address in title and h1"}
{"id":"test-loom-6oq","title":"Create initial git commit for goifaces","description":"Stage all project files and create the initial commit. Verify pre-commit hook runs lint + tests successfully. Do NOT commit logs/ or testdata/*/output.* files (gitignored).","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:44.018283-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T10:55:38.076036-06:00","closed_at":"2026-02-19T10:55:38.076036-06:00","close_reason":"Initial commit 9f31a3a created. Pre-commit hook verified lint + tests pass."}
{"id":"test-loom-6t1","title":"Implement input resolver package","description":"internal/resolver/resolver.go - resolves local dirs, sub-package paths, and GitHub URLs (git clone --depth=1) to analyzable directories","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:48.459913-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:05:52.258219-06:00","closed_at":"2026-02-19T09:05:52.258219-06:00","close_reason":"Implemented with local dir, GitHub URL clone, and go mod download"}
{"id":"test-loom-720","title":"Create Mermaid syntax verifier for CI and development","description":"Add a verification step that validates generated Mermaid code against Mermaid.js parser (not just mmdc CLI). Should catch syntax errors before serving to browser. Can use Node.js mermaid package or mmdc --parseOnly.","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T16:07:55.764085-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:11:04.387828-06:00","closed_at":"2026-02-19T16:11:04.387828-06:00","close_reason":"Closed"}
{"id":"test-loom-7r8","title":"Implement structured logging package","description":"internal/logging/logging.go - slog JSON handler with dual output (stderr + file), Setup function returning logger and cleanup","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:30.406814-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:05:35.054043-06:00","closed_at":"2026-02-19T09:05:35.054043-06:00","close_reason":"Implemented with slog JSONHandler and io.MultiWriter"}
{"id":"test-loom-86t","title":"Implement Mermaid diagram generator","description":"internal/diagram/mermaid.go - generates deterministic classDiagram syntax with sanitized IDs, method truncation, and sorted output","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:06:05.360739-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:06:09.108986-06:00","closed_at":"2026-02-19T09:06:09.108986-06:00","close_reason":"Implemented with deterministic sorting, relevant method filtering, and pointer-receiver labels"}
{"id":"test-loom-873","title":"Mermaid syntax error in browser - Unicode sanitization chars not supported by Mermaid.js v11","description":"The sanitizeSignature() function in internal/diagram/mermaid.go replaces {}\u003c\u003e with Unicode alternatives (⦃⦄ᐊ‹›) that pass mmdc CLI rendering but fail in browser Mermaid.js v11.12.3. Need to use only ASCII-safe replacements that work in both contexts.","status":"closed","priority":1,"issue_type":"bug","owner":"olesho@gmail.com","created_at":"2026-02-19T15:48:38.349512-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:11:04.294301-06:00","closed_at":"2026-02-19T16:11:04.294301-06:00","close_reason":"Closed"}
{"id":"test-loom-944","title":"Replace Overview slide with package map visualization","description":"Replace the first 'Overview' slide with a visualization showing the map of all packages in the repository. Each package may contain subpackages (nested). Use a different Mermaid chart type suitable for hierarchical package visualization. The existing detail slides (split into many slides showing interfaces/implementations) should remain unchanged.","design":"## Summary\n\nReplace the Overview slide (slide 0) with a Package Map visualization that shows the hierarchical structure of all Go packages in the analyzed repository. Currently, the overview slide shows a classDiagram with only interface nodes and embedding arrows. The new package map will use a Mermaid flowchart with nested subgraphs to represent the package tree, giving users an at-a-glance understanding of the project's package organization and where interfaces and types live. The existing detail slides (interface+implementation diagrams split by hub-and-spoke) remain unchanged.\n\n## Technical Approach\n\n**Mermaid chart type:** `flowchart TD` (top-down) with nested subgraphs. This is the most natural and well-supported Mermaid representation for hierarchical data. Each package becomes a `subgraph` labeled with its short name, and nested packages become nested subgraphs. Leaf/inner packages with interfaces or types get an info node showing counts (e.g., \"3 interfaces · 5 types\").\n\n**Key design decisions:**\n- Use `flowchart TD` instead of `classDiagram` — subgraphs naturally represent package containment\n- Strip the module path prefix to show only relative package paths (e.g., `internal/analyzer` instead of `github.com/foo/bar/internal/analyzer`)\n- Build an in-memory package tree from `PkgPath` strings, filling in intermediate nodes that may not directly contain types\n- Show interface/type counts per package as info nodes within subgraphs\n- Style subgraphs with the existing blue color scheme for visual consistency\n\n**Trade-offs:**\n- Flowchart subgraphs vs block-beta: Flowchart subgraphs are more mature and widely supported in Mermaid v11. Block-beta is newer but less tested.\n- Showing counts vs individual type names: Counts keep the map clean and readable. Individual names would create visual clutter — that's what the detail slides are for.\n- Mermaid subgraph nesting depth: Works well for typical Go projects (2-4 levels). Very deep nesting (5+) may render awkwardly, but this is rare in practice.\n\n## Files to Create\n\n### `goifaces/internal/diagram/pkgmap.go`\nNew file containing the package map generation logic:\n- `type pkgNode struct` — tree node: name, full path, children map, interface count, type count\n- `func buildPackageTree(result *analyzer.Result) *pkgNode` — extracts unique PkgPaths from interfaces and types, strips common module prefix, builds tree\n- `func generatePackageMapMermaid(result *analyzer.Result, opts DiagramOptions) string` — renders the package tree as a Mermaid `flowchart TD` with nested subgraphs\n- Helper: `func longestCommonPathPrefix(paths []string) string` — finds module path to strip\n- Helper: `func renderSubgraph(b *strings.Builder, node *pkgNode, depth int)` — recursive subgraph renderer\n\nThe flowchart output will look like:\n```\nflowchart TD\n    subgraph root[\"mymodule\"]\n        subgraph internal_sg[\"internal\"]\n            subgraph analyzer_sg[\"analyzer\"]\n                analyzer_info[\"3 interfaces · 5 types\"]\n            end\n            subgraph diagram_sg[\"diagram\"]\n                diagram_info[\"1 interface\"]\n                subgraph split_sg[\"split\"]\n                    split_info[\"1 interface · 1 type\"]\n                end\n            end\n        end\n    end\n```\n\nSubgraph IDs use `{sanitizedPkgName}_sg` pattern to avoid collisions with existing node ID conventions. Info nodes use `{sanitizedPkgName}_info`.\n\nFor packages with no direct types/interfaces (pure organizational packages), no info node is rendered — they appear as empty subgraphs containing only their children.\n\n### `goifaces/internal/diagram/pkgmap_test.go`\nUnit tests for the package tree building and rendering:\n- `TestBuildPackageTree` — verifies tree structure from sample PkgPaths\n- `TestLongestCommonPathPrefix` — edge cases: single package, no common prefix, identical paths\n- `TestGeneratePackageMapMermaid` — verifies Mermaid output contains expected subgraphs and info nodes\n\n## Files to Modify\n\n### `goifaces/internal/diagram/slides.go`\n**Lines 45-49:** Replace the `generateOverviewMermaid` call with `generatePackageMapMermaid`:\n```go\n// Slide 0: package map — hierarchical view of all packages\nslides = append(slides, Slide{\n    Title:   \"Package Map\",\n    Mermaid: generatePackageMapMermaid(result, diagOpts),\n})\n```\n\n**Lines 108-215:** Remove the entire `generateOverviewMermaid` function and `collectEmbeddingArrows` function. These are only used for the old overview slide and will be replaced by the new pkgmap.go code.\n\n### `goifaces/internal/integration_test.go`\n**`TestHubAndSpokeSlides` (line 328):**\n- Change `assert.Equal(t, \"Overview\", slides[0].Title)` to `assert.Equal(t, \"Package Map\", slides[0].Title)`\n- Update assertions about overview content: instead of checking for interface nodes and embedding arrows, check for flowchart subgraph markers (e.g., `subgraph`, package names)\n- Keep the assertion that impl types don't appear (they shouldn't be in the package map either)\n- Keep the detail slide assertions unchanged\n\n**`TestOverviewInterfaceEmbedding` (line 449):**\nRewrite this test as `TestPackageMapSlide`:\n- Create a synthetic Result with types in multiple packages (e.g., `example.com/app/models`, `example.com/app/handlers`, `example.com/app/handlers/middleware`)\n- Verify the package map slide contains subgraphs for each package level\n- Verify package counts are shown correctly\n- Verify the flowchart chart type is used (contains \"flowchart\")\n- Verify no classDiagram artifacts appear\n\n### `goifaces/docs/architecture.md`\n**Line 62 (internal/diagram section):** Update the description of the overview slide:\n- Change \"The overview (first) slide shows only interface nodes with interface→interface embedding/extension arrows\" to \"The overview (first) slide shows a Package Map — a hierarchical flowchart visualization of all Go packages using nested subgraphs, with interface/type counts per package\"\n\n## Dependencies\n\n- No new external packages needed\n- Internal: `analyzer.Result` (existing), `DiagramOptions` (existing)\n- The `go/types` import in slides.go can be removed since `collectEmbeddingArrows` (which uses it) is being deleted\n\n## Edge Cases \u0026 Error Handling\n\n1. **Single package (no nesting):** If all types are in one package, render a single subgraph with an info node. No nested subgraphs needed.\n2. **No types/interfaces found:** Return a minimal `flowchart TD` with just \"No packages found\" text node. (This case is already handled upstream — the pipeline exits early if result is empty.)\n3. **Very deep nesting (5+ levels):** Mermaid handles this, though rendering may be less ideal. No special handling needed — Go projects rarely exceed 4 levels.\n4. **Packages with identical short names (e.g., `foo/bar` and `baz/bar`):** Node IDs must be unique. Use the full relative path (sanitized) as the subgraph ID, not just the short name.\n5. **Module prefix stripping:** If all types share a common module prefix (e.g., `github.com/user/repo`), strip it. If only one package exists, use just its short name. If packages come from different modules (e.g., stdlib included), find the longest common prefix at `/` boundaries.\n6. **Empty intermediate packages:** Packages like `internal/` that have no direct types but contain subpackages should still appear as subgraph containers.\n7. **Special characters in package names:** Already handled by existing `sanitizeID` function (replaces `/`, `.`, `-` with `_`).\n\n## Testing Strategy\n\n### Unit Tests (pkgmap_test.go)\n1. **TestBuildPackageTree:** Verify tree building from various PkgPath inputs:\n   - Multiple packages at different depths\n   - Single package (flat)\n   - Packages with shared prefixes\n2. **TestLongestCommonPathPrefix:** Test edge cases:\n   - Empty input → empty string\n   - Single path → the path itself up to last segment\n   - Two paths with partial overlap\n   - Identical paths\n3. **TestGeneratePackageMapMermaid:**\n   - Verify output starts with \"flowchart TD\"\n   - Verify subgraph nesting matches package hierarchy\n   - Verify info nodes contain correct counts\n   - Verify sanitized IDs are used\n\n### Integration Tests (integration_test.go)\n4. **TestHubAndSpokeSlides (updated):** Verify package map is slide 0 with correct title\n5. **TestPackageMapSlide (new):** End-to-end test with multi-package synthetic data\n\n### Manual Verification\n6. Run `bash scripts/visual-verify.sh` after implementation\n7. Run the tool on a real Go project and verify the package map renders correctly in the browser","status":"closed","priority":2,"issue_type":"feature","owner":"olesho@gmail.com","created_at":"2026-02-21T08:07:36.726755-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-21T08:13:08.281729-06:00","closed_at":"2026-02-21T08:13:08.281729-06:00","close_reason":"Replaced Overview slide with Package Map flowchart showing package hierarchy with interface/type counts"}
{"id":"test-loom-9q0","title":"Show only interfaces and relations on the first (overview) slide","description":"The first Mermaid chart, titled 'Overview', currently shows interfaces, implementations, and all details. It should instead be a unified map showing ONLY interfaces and their relations (dependency arrows between interfaces). No implementation blocks, no method bodies — just the interface nodes and how they connect. Only modify the 'Overview' chart; the chunked slides that follow should keep their current detail level.","design":"## Summary\n\nThe overview (first) slide currently shows ALL nodes (interfaces and implementations) with empty class bodies plus all type→interface relation arrows. This task changes the overview to show ONLY interface nodes and interface→interface embedding/extension arrows, producing a clean architectural map. Implementation blocks and implementation arrows are omitted entirely from the overview — they remain on the detail slides that follow.\n\n## Technical Approach\n\nThe change is localized to `generateOverviewMermaid()` in `internal/diagram/slides.go`. The function already has special logic for the overview (no method bodies). We extend this by:\n\n1. **Removing type/implementation blocks** — Delete the entire section that renders type class blocks (lines 168-177 in current code).\n2. **Replacing type→interface relations with interface→interface embedding arrows** — Instead of iterating `result.Relations` (which are type→interface), detect interface embedding using each `InterfaceDef.TypeObj` (`*types.Interface`). The `NumEmbeddeds()` and `EmbeddedType(i)` methods from Go's `go/types` package reveal which interfaces embed other interfaces.\n3. **Using a different arrow style** — Implementation uses `..|\u003e` (dashed + triangle). Interface embedding/extension should use `--|\u003e` (solid + triangle), following UML convention for inheritance/extension.\n4. **Handling nil TypeObj** — Synthetic test data may have nil `TypeObj`. When nil, skip embedding detection for that interface (no arrows drawn from it).\n5. **Removing implStyle** — Since no implementation blocks are rendered, remove `classDef implStyle` and its `cssClass` assignments from the overview output.\n\nIf a codebase has no interface embedding, the overview shows just the interface nodes (a useful \"table of contents\"). The detail slides remain unchanged.\n\n## Files to Modify\n\n### 1. `internal/diagram/slides.go` — `generateOverviewMermaid()`\n\n**Remove type blocks section (current lines ~168-177):**\n- Delete the loop that writes type class blocks\n- Delete the blank-line separator between interfaces and types\n\n**Replace relation rendering (current lines ~179-186):**\n- Remove the loop that writes `type ..|\u003e interface` arrows\n- Add new logic:\n  a. Build a lookup map: `pkgPath.Name → bool` for all interfaces in the result\n  b. For each interface with non-nil `TypeObj`, iterate `TypeObj.NumEmbeddeds()`\n  c. For each `TypeObj.EmbeddedType(i)`, check if it's a `*types.Named` whose `Obj().Pkg().Path() + \".\" + Obj().Name()` exists in the lookup\n  d. If so, write an embedding arrow: `childID --|\u003e parentID`\n  e. Sort embedding arrows deterministically\n\n**Remove implStyle references (current lines ~189-198):**\n- Remove `classDef implStyle ...` line from style definitions\n- Remove the loop that assigns `cssClass` to type nodes (since no type nodes exist)\n\n**Add a new helper function `writeEmbeddingRelation()`:**\n```go\nfunc writeEmbeddingRelation(b *strings.Builder, child, parent analyzer.InterfaceDef) {\n    childID := nodeID(child.PkgName, child.Name)\n    parentID := nodeID(parent.PkgName, parent.Name)\n    b.WriteString(fmt.Sprintf(\"    %s --|\u003e %s\", childID, parentID))\n}\n```\n\n### 2. `internal/integration_test.go` — `TestHubAndSpokeSlides`\n\n**Update overview assertions (around line 421-423):**\n- Keep the existing `assert.NotContains(t, overview, \"+\", \"overview should have no method lines\")` assertion\n- Add: overview should NOT contain any implementation node IDs (e.g., `memdb_BoolFieldIndex`, `memdb_FilterIterator`)\n- Add: overview should NOT contain `..|\u003e` arrows (implementation relations)\n- Add: overview SHOULD contain interface node IDs (`memdb_Indexer`, `memdb_MultiIndexer`, etc.)\n\n**Add a new test `TestOverviewInterfaceEmbedding`:**\n- Create synthetic data with 3 interfaces where one embeds the other two (like ReadCloser embedding Reader and Closer)\n- Use real `*types.Interface` objects (via `types.NewInterfaceType`) so `TypeObj` is populated\n- Verify the overview contains `--|\u003e` arrows between the embedding interface and its parents\n- Verify no implementation blocks or `..|\u003e` arrows appear\n\n### 3. `docs/architecture.md` — Update `internal/diagram` section\n\nUpdate the paragraph describing the diagram package to mention that the overview slide shows only interface nodes with embedding/extension arrows (`--|\u003e`), while detail slides show full interface+implementation diagrams with implementation arrows (`..|\u003e`).\n\n## Dependencies\n\n- No new external packages needed\n- Uses existing `go/types` stdlib for embedding detection (`types.Interface.NumEmbeddeds()`, `types.Interface.EmbeddedType()`)\n- No dependency on in-progress task test-loom-xf7 (that task modifies detail slide rendering in `mermaid.go`, not overview in `slides.go`)\n\n## Edge Cases \u0026 Error Handling\n\n1. **Nil TypeObj** — Synthetic test data or edge cases may have nil `TypeObj`. Skip embedding detection for these interfaces; they'll render as disconnected nodes.\n2. **Self-embedding** — Go doesn't allow it, but guard: skip if child == parent by key.\n3. **Embedded type is not *types.Named** — `EmbeddedType(i)` could return a non-Named type (e.g., type constraints in generics). Only process `*types.Named` types.\n4. **Embedded interface not in result set** — If an interface embeds a stdlib interface not in our result (e.g., `io.Reader`), skip the arrow since the parent node doesn't exist in the diagram.\n5. **No interfaces at all** — The overview renders just `classDiagram` with no nodes. This matches current behavior for empty results.\n6. **No embeddings** — Overview shows interface nodes with no arrows. This is correct — it serves as a table of contents.\n7. **Embedded type's Obj().Pkg() is nil** — Universe-scope types like `error` have nil Pkg(). Handle this by checking for nil before accessing `Pkg().Path()`.\n\n## Testing Strategy\n\n1. **Existing test `TestHubAndSpokeSlides`** — Update assertions for overview slide to verify no impl nodes and no `..|\u003e` arrows\n2. **New test `TestOverviewInterfaceEmbedding`** — Verify embedding arrows appear correctly using synthetic interface types\n3. **Manual verification** — Run on testdata/05_embedded_iface to verify ReadCloser → Reader and ReadCloser → Closer arrows appear in overview\n4. **Run `go test ./...`** — All existing tests must pass\n5. **Run `golangci-lint run ./...`** — No lint errors\n6. **Run `bash scripts/visual-verify.sh`** — Visual check of rendered SVGs","status":"closed","priority":2,"issue_type":"task","assignee":"nova","owner":"olesho@gmail.com","created_at":"2026-02-20T05:08:13.910905-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-20T09:31:21.174566-06:00","closed_at":"2026-02-20T09:31:21.174566-06:00","close_reason":"Completed: overview slide now shows only interface nodes with embedding arrows (--|\u003e). Implementation blocks, impl arrows (..|\u003e), and implStyle removed. Tests updated and new TestOverviewInterfaceEmbedding added."}
{"id":"test-loom-a0i","title":"Implement HTTP server with Mermaid.js rendering","description":"internal/server/server.go - serves HTML with Mermaid.js CDN v11, zoom controls, copy button, auto-browser-open, graceful shutdown","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:06:16.076028-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:06:19.490009-06:00","closed_at":"2026-02-19T09:06:19.490009-06:00","close_reason":"Implemented with dark/light mode, zoom, copy, and graceful shutdown"}
{"id":"test-loom-a8u","title":"Implement core analyzer package","description":"internal/analyzer/ - types.go (InterfaceDef, TypeDef, MethodSig, Relation, Result), analyzer.go (package loading via go/packages, interface/type collection, types.Implements matching), filter.go (stdlib/unexported/prefix filtering, orphan pruning)","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:39.671251-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:05:44.098826-06:00","closed_at":"2026-02-19T09:05:44.098826-06:00","close_reason":"Implemented with stdlib interface loading, error builtin handling, and all filtering"}
{"id":"test-loom-awj","title":"Mermaid syntax error when rendering go-memdb diagram in browser","description":"Running './goifaces https://github.com/hashicorp/go-memdb -port 8081' produces a Mermaid diagram that fails to render in the browser with 'Syntax error in text, mermaid version 11.12.3'. Need to investigate the generated Mermaid output for invalid syntax.","status":"closed","priority":1,"issue_type":"bug","owner":"olesho@gmail.com","created_at":"2026-02-19T15:38:56.242547-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T15:42:24.034549-06:00","closed_at":"2026-02-19T15:42:24.034549-06:00","close_reason":"Closed"}
{"id":"test-loom-ayh","title":"Run visual verification on all test diagrams","description":"Run 'bash scripts/visual-verify.sh' to render all testdata Mermaid outputs to SVG via mmdc. Then visually inspect each SVG to confirm diagrams match the input Go code. Prerequisite: npm install -g @mermaid-js/mermaid-cli","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:40.313985-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:47:39.122746-06:00","closed_at":"2026-02-19T16:47:39.122746-06:00","close_reason":"Closed"}
{"id":"test-loom-bnt","title":"Implement LLM-backed enrichers (iteration 2)","description":"Swap no-op default enrichers with LLM-backed implementations: 1) Semantic grouper - identify architectural layers 2) Pattern detector - recognize design patterns 3) Diagram simplifier - intelligent pruning 4) Annotator - add descriptions 5) Relationship scorer - rank by importance. All interfaces already defined in internal/enricher/.","design":"## Summary\n\nReplace the five no-op/mechanical default enrichers with LLM-backed implementations that provide semantic understanding of Go interface-implementation graphs. This transforms the enricher pipeline from purely syntactic (group-by-package, equal-weight scoring) to semantically intelligent (identify architectural layers, recognize design patterns, smart pruning, human-readable annotations, importance-based scoring). The LLM enrichers degrade gracefully to the existing defaults on failure.\n\n## Technical Approach\n\n### LLM Client Abstraction\n\nCreate a lightweight LLM client in \\`internal/enricher/llm/client.go\\` that speaks the **OpenAI-compatible chat completions API** (the most universal protocol — works with OpenAI, Anthropic via proxy, Ollama, vLLM, any OpenAI-compatible endpoint). No external SDK dependency — use stdlib \\`net/http\\` + \\`encoding/json\\`.\n\nThe client:\n- Takes an endpoint URL, API key, and model name via configuration\n- Sends chat completion requests with JSON mode (\\`response_format: {type: \"json_object\"}\\`)\n- Returns raw JSON string for each enricher to parse into its own typed response\n- Includes timeout, retries (1 retry on 5xx), and structured logging via \\`slog\\`\n\n### Configuration\n\nAdd a CLI flag \\`--enrich\\` (boolean, default false) to enable LLM enrichment. When enabled, read:\n- \\`GOIFACES_LLM_ENDPOINT\\` — API base URL (default: \\`https://api.openai.com/v1\\`)\n- \\`GOIFACES_LLM_API_KEY\\` — API key (required when --enrich is set)\n- \\`GOIFACES_LLM_MODEL\\` — model identifier (default: \\`gpt-4o-mini\\`)\n\nThese are env vars rather than flags because they contain secrets (API key) and rarely change between runs.\n\n### Enricher Implementations\n\nEach LLM enricher lives in a new file \\`internal/enricher/llm_\u003cname\u003e.go\\` (e.g., \\`llm_grouper.go\\`). Each:\n1. Implements the existing \\`Enricher\\` interface plus its domain-specific interface\n2. Takes a \\`*llm.Client\\` and the default enricher as constructor args\n3. Serializes the relevant parts of \\`analyzer.Result\\` into a focused prompt\n4. Parses the JSON response into the expected return type\n5. Falls back to the default enricher on any error (logs the failure at WARN level)\n\n#### 1. LLM Semantic Grouper (\\`llm_grouper.go\\`)\n\n**Prompt strategy:** Send a list of interfaces and types with their package paths, method signatures, and implementation relationships. Ask the LLM to identify architectural layers/domains (e.g., \"Data Access\", \"Business Logic\", \"HTTP Transport\", \"Domain Models\").\n\n**JSON response schema:**\n\\`\\`\\`json\n{\n  \"groups\": [\n    {\n      \"name\": \"Data Access Layer\",\n      \"interfaces\": [\"pkg.InterfaceName\"],\n      \"types\": [\"pkg.TypeName\"]\n    }\n  ]\n}\n\\`\\`\\`\n\n**Enrich behavior:** The \\`Enrich()\\` method returns the result unchanged (grouping is consumed separately by diagram generation). The \\`Group()\\` method returns the LLM-identified semantic groups.\n\n#### 2. LLM Pattern Detector (\\`llm_patterns.go\\`)\n\n**Prompt strategy:** Send the interface graph (interfaces with methods, types, which type implements which interface). Ask the LLM to identify GoF and Go-specific patterns (Strategy, Factory, Repository, Observer, Decorator, Adapter, etc.).\n\n**JSON response schema:**\n\\`\\`\\`json\n{\n  \"patterns\": [\n    {\n      \"name\": \"Strategy\",\n      \"description\": \"Multiple interchangeable algorithms behind a common interface\",\n      \"participants\": [\"pkg.Interface\", \"pkg.ImplA\", \"pkg.ImplB\"]\n    }\n  ]\n}\n\\`\\`\\`\n\n**Enrich behavior:** \\`Enrich()\\` returns result unchanged. \\`Detect()\\` returns detected patterns.\n\n#### 3. LLM Diagram Simplifier (\\`llm_simplifier.go\\`)\n\n**Prompt strategy:** When node count exceeds \\`maxNodes\\`, send the full graph and ask the LLM to identify the \\`maxNodes\\` most architecturally significant nodes to keep, preserving the most informative relationships. The LLM should prefer keeping hub interfaces and types that bridge different domains.\n\n**JSON response schema:**\n\\`\\`\\`json\n{\n  \"keep\": [\"pkg.Name1\", \"pkg.Name2\"]\n}\n\\`\\`\\`\n\n**Enrich behavior:** \\`Enrich()\\` uses the LLM to intelligently select which nodes to keep (rather than the default edge-count heuristic). \\`Simplify()\\` performs the actual filtering based on the LLM's selection.\n\n#### 4. LLM Annotator (\\`llm_annotator.go\\`)\n\n**Prompt strategy:** Send interfaces and types with their methods and relationships. Ask the LLM to generate concise (\u003c 80 char) human-readable descriptions for each, explaining their role/purpose.\n\n**JSON response schema:**\n\\`\\`\\`json\n{\n  \"annotations\": {\n    \"pkg.Name\": \"Brief description of purpose\"\n  }\n}\n\\`\\`\\`\n\n**Enrich behavior:** \\`Enrich()\\` returns result unchanged. \\`Annotate()\\` returns the annotation map.\n\n#### 5. LLM Relationship Scorer (\\`llm_scorer.go\\`)\n\n**Prompt strategy:** Send all relationships (type → interface pairs). Ask the LLM to score each by architectural importance (0.0–1.0), where core domain relationships score high and incidental implementations (e.g., implementing \\`error\\` or \\`fmt.Stringer\\`) score low.\n\n**JSON response schema:**\n\\`\\`\\`json\n{\n  \"scores\": {\n    \"0\": 0.9,\n    \"1\": 0.3\n  }\n}\n\\`\\`\\`\n\nKeys are string-encoded relation indices matching the input order.\n\n**Enrich behavior:** \\`Enrich()\\` returns result unchanged. \\`Score()\\` returns the weighted scores.\n\n### Result Serialization\n\nCreate a helper \\`internal/enricher/llm/serialize.go\\` that converts \\`analyzer.Result\\` into a compact text representation for prompts:\n- List interfaces: name, package, method signatures (truncated if \u003e10 methods)\n- List types: name, package, key methods\n- List relationships: \"TypeName implements InterfaceName\"\n- Keep total prompt size reasonable (estimate ~4K tokens for a medium project)\n\n### Wiring in main.go\n\nWhen \\`--enrich\\` is set:\n1. Create \\`llm.Client\\` from env vars\n2. Replace the enricher pipeline with LLM-backed enrichers:\n   \\`\\`\\`go\n   enrichers := []enricher.Enricher{\n       enricher.NewLLMGrouper(llmClient, enricher.NewDefaultGrouper()),\n       enricher.NewLLMSimplifier(llmClient, enricher.NewDefaultSimplifier()),\n   }\n   \\`\\`\\`\n3. Optionally run pattern detection and annotation as separate steps (their results feed into diagram generation, not the Result pipeline)\n\n### Error Handling \u0026 Fallback\n\nEvery LLM enricher wraps a default enricher. On any error:\n1. Log at WARN level with \\`component=enricher\\`, error details, and which enricher failed\n2. Return the default enricher's result\n3. Continue the pipeline — a single enricher failure does not abort the run\n\n### Token Budget\n\nEach enricher prompt is self-contained and focused. For a medium project (20 interfaces, 50 types, 100 relations):\n- Grouper prompt: ~2K tokens input, ~500 tokens output\n- Pattern detector: ~2K tokens input, ~500 tokens output\n- Simplifier: ~1.5K tokens input, ~200 tokens output\n- Annotator: ~2K tokens input, ~1K tokens output\n- Scorer: ~1K tokens input, ~500 tokens output\n\nTotal: ~12K tokens per run. With gpt-4o-mini at $0.15/1M input + $0.60/1M output, this costs ~$0.002 per run.\n\n## Files to Create\n\n1. **\\`internal/enricher/llm/client.go\\`** — LLM HTTP client (OpenAI-compatible chat completions, JSON mode, retries, timeout)\n2. **\\`internal/enricher/llm/serialize.go\\`** — Helper to serialize \\`analyzer.Result\\` into compact prompt text\n3. **\\`internal/enricher/llm/client_test.go\\`** — Unit tests for client with httptest mock server\n4. **\\`internal/enricher/llm_grouper.go\\`** — LLM-backed semantic grouper\n5. **\\`internal/enricher/llm_patterns.go\\`** — LLM-backed pattern detector\n6. **\\`internal/enricher/llm_simplifier.go\\`** — LLM-backed intelligent simplifier\n7. **\\`internal/enricher/llm_annotator.go\\`** — LLM-backed annotator\n8. **\\`internal/enricher/llm_scorer.go\\`** — LLM-backed relationship scorer\n\n## Files to Modify\n\n1. **\\`main.go\\`** — Add \\`--enrich\\` flag, env var reading, conditional LLM enricher pipeline construction\n2. **\\`docs/architecture.md\\`** — Document the LLM enricher subsystem, client abstraction, fallback behavior\n3. **\\`docs/cli-reference.md\\`** — Document \\`--enrich\\` flag and required env vars\n4. **\\`internal/integration_test.go\\`** — Add integration test for LLM enricher pipeline (using mock HTTP server)\n\n## Dependencies\n\n- **No new external Go modules required** — uses stdlib \\`net/http\\` + \\`encoding/json\\` for the LLM client\n- Internal: depends on \\`internal/analyzer\\` (types), \\`internal/enricher\\` (interfaces)\n- External runtime: requires an OpenAI-compatible API endpoint when \\`--enrich\\` is enabled\n\n## Edge Cases \u0026 Error Handling\n\n1. **Missing API key with --enrich**: Print clear error message and exit (fail fast, don't silently fall back)\n2. **LLM returns malformed JSON**: Log warning, fall back to default enricher\n3. **LLM returns valid JSON but missing/extra fields**: Use what's available, ignore extras, fall back for missing\n4. **LLM timeout (default 30s per request)**: Log warning, fall back to default\n5. **LLM returns node keys that don't match any actual node**: Ignore unknown keys, only use valid references\n6. **Empty result (0 interfaces/types)**: Skip LLM calls entirely, return defaults immediately\n7. **Very large projects (\u003e100 types)**: Truncate the prompt by including only the most-connected nodes (pre-filter using edge count before sending to LLM)\n8. **Rate limiting (429)**: Respect Retry-After header, retry once, then fall back\n\n## Testing Strategy\n\n### Unit Tests\n- **\\`internal/enricher/llm/client_test.go\\`**: Test HTTP client against \\`httptest\\` mock server — success, timeout, 5xx retry, malformed response, JSON mode header\n- Each LLM enricher file gets table-driven tests with mock LLM responses (use a mock client interface)\n\n### Integration Tests\n- Add test in \\`internal/integration_test.go\\` that:\n  1. Starts a mock HTTP server returning canned LLM responses\n  2. Creates LLM enrichers pointed at the mock\n  3. Runs the full pipeline on testdata/01_single_iface\n  4. Asserts the enriched result has groups, patterns, annotations, scores\n  5. Tests fallback: mock returns 500, verify default enricher result is used\n\n### Manual Verification\n- Run \\`goifaces --enrich ./testdata/01_single_iface -output test.mmd\\` against a real LLM endpoint\n- Inspect logs for LLM request/response details at DEBUG level\n- Compare diagram output with and without \\`--enrich\\` flag","status":"closed","priority":4,"issue_type":"feature","assignee":"nova","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:44.690964-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-20T18:13:04.262044-06:00","closed_at":"2026-02-20T18:13:04.262044-06:00","close_reason":"Implemented all 5 LLM-backed enrichers with fallback, client abstraction, tests, and documentation"}
{"id":"test-loom-c29","title":"Package Map: remove \\n escape characters from package names","description":"Some package names in the Package Map display literal backslash-n sequences like 'schema\\n1 types', 'tools\\n2 types'. These \\n1, \\n2 characters are appearing in the rendered output. Investigate why these escape sequences are being inserted into package name labels and fix the generation so names render cleanly without any such characters.","design":"## Summary\n\nThe `formatPkgLabel` function in `goifaces/internal/diagram/slides.go` (line 256 on main) uses `fmt.Sprintf(\"%s\\\\n%s\", ...)` which produces the literal two-character sequence `\\n` in the output string. This is a Go string escaping issue: `\\\\n` in a Go double-quoted string is a backslash followed by the letter n, not a newline character. Mermaid does not interpret literal `\\n` as a line break, so labels like `schema\\n1 types` render with the backslash-n visible.\n\nThe fix is to replace `\\\\n` with `\u003cbr/\u003e` — the standard Mermaid mechanism for line breaks inside node labels that use the `[\"...\"]` (double-quote) syntax.\n\n## Technical Approach\n\n**Root cause:** In Go, `\"\\\\n\"` produces the literal string `\\n` (two chars). The Mermaid renderer treats this as plain text, not a line break. Mermaid flowchart nodes using `[\"...\"]` syntax support `\u003cbr/\u003e` for line breaks.\n\n**Fix:** Change the format string from `\"%s\\\\n%s\"` to `\"%s\u003cbr/\u003e%s\"`.\n\n**Why `\u003cbr/\u003e` over alternatives:**\n- Mermaid markdown strings (backtick syntax `[\"\\` ... \\`\"]`) support actual newlines, but switching the entire node syntax is a larger change and the current `[\"...\"]` syntax is used throughout `renderTree`.\n- `\u003cbr\u003e` also works but `\u003cbr/\u003e` is the self-closing XHTML form, which is more correct for SVG output (the rendering pipeline uses `mmdc` to produce SVG).\n- Actual `\\n` (newline character, i.e. `\"%s\\n%s\"` in Go) would break the Mermaid syntax since the node definition must be on a single line in the `[\"...\"]` form.\n\n## Files to Modify\n\n### 1. `goifaces/internal/diagram/slides.go` (line 256)\n\n**Change:** In `formatPkgLabel`, replace:\n```go\nreturn fmt.Sprintf(\"%s\\\\n%s\", name, strings.Join(parts, \", \"))\n```\nwith:\n```go\nreturn fmt.Sprintf(\"%s\u003cbr/\u003e%s\", name, strings.Join(parts, \", \"))\n```\n\nThis is the only code change needed. The function is called from `renderTree` which embeds the label in `[\"...\"]` Mermaid syntax. The `\u003cbr/\u003e` will be correctly interpreted by Mermaid as a line break.\n\n## Files to Create\n\nNone.\n\n## Dependencies\n\nNo new external dependencies. The fix uses standard Mermaid HTML syntax that is already supported.\n\n## Edge Cases \u0026 Error Handling\n\n1. **Packages with only a name (no stats):** Already handled — `formatPkgLabel` returns early with just the name when `s == nil` or when both counts are zero. No `\u003cbr/\u003e` is inserted.\n2. **Packages with only interfaces or only types:** Works correctly — only non-zero counts are appended, and `\u003cbr/\u003e` separates name from the stats line.\n3. **SVG rendering:** `\u003cbr/\u003e` is valid XHTML and renders correctly in SVG via `mmdc` (Mermaid CLI).\n4. **Mermaid quoting:** The `\u003cbr/\u003e` appears inside `[\"...\"]` which is standard Mermaid double-quote string syntax. HTML tags are supported within these strings.\n\n## Testing Strategy\n\n### 1. Update existing tests in `goifaces/internal/integration_test.go`\n\nThe existing `TestPackageMapMultiPackage` test asserts `Contains(pkgMap, \"2 ifaces\")` and `Contains(pkgMap, \"1 ifaces\")`. These assertions will still pass because the stats text itself is unchanged — only the separator between name and stats changes from `\\n` to `\u003cbr/\u003e`.\n\n### 2. Add a unit test for `formatPkgLabel` specifically\n\nAdd a new test `TestFormatPkgLabel` that verifies:\n- A label with stats produces `\"name\u003cbr/\u003eN ifaces, M types\"` (not `\"name\\nN ifaces, M types\"`)\n- A label with nil stats returns just the name\n- A label with only interfaces returns `\"name\u003cbr/\u003eN ifaces\"`\n- A label with only types returns `\"name\u003cbr/\u003eN types\"`\n\n### 3. Add a negative assertion\n\nIn the existing `TestPackageMapMultiPackage`, add:\n```go\nassert.NotContains(t, pkgMap, `\\n`, \"package map labels should not contain literal backslash-n\")\n```\n\n### 4. Visual verification\n\nRun `bash scripts/visual-verify.sh` after the fix and inspect the SVG output to confirm labels render on two lines without literal `\\n` characters.","status":"closed","priority":2,"issue_type":"bug","assignee":"nova","owner":"olesho@gmail.com","created_at":"2026-02-21T08:32:43.616112-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-21T09:10:27.468456-06:00","closed_at":"2026-02-21T09:10:27.468456-06:00","close_reason":"Fixed formatPkgLabel to use \u003cbr/\u003e instead of literal \\n for Mermaid line breaks. Added tests for all label formatting cases.","dependencies":[{"issue_id":"test-loom-c29","depends_on_id":"test-loom-944","type":"blocks","created_at":"2026-02-21T08:32:46.933414-06:00","created_by":"Oleh Luchkiv"}]}
{"id":"test-loom-cmz","title":"Package Map: exclude external packages, use only local repo packages","description":"The Package Map visualization currently includes packages from github.com and other external dependencies. It should only show local packages from the repository being analyzed. Filter out any external/third-party packages and only display packages that belong to the analyzed codebase.","design":"## Summary\n\nThe Package Map visualization includes interfaces from external/third-party packages (e.g., github.com/stretchr/testify, golang.org/x/tools) because the analyzer collects interfaces from all imported packages without checking whether they belong to the analyzed module. This fix parses the module path from go.mod and uses it to filter out external packages at both collection time (in Analyze) and filtering time (in Filter), so only interfaces and types belonging to the local module appear in diagrams.\n\n## Technical Approach\n\n**Root cause:** In `analyzer.go:124-129`, the imports loop calls `collectFromScope` on every imported package's type scope, including external dependencies. The `Filter` function only excludes stdlib packages (via `isStdlib`), not third-party packages like `github.com/...`.\n\n**Solution:** Parse the module path from `go.mod` and filter at two levels:\n\n1. **Collection-time filtering (Analyze):** In the imports loop, skip any imported package whose PkgPath does NOT start with the module path. Stdlib packages are already handled separately via the IncludeStdlib flag. Since \\`packages.Load(\"./...\")\\` already loads ALL local packages, the imports loop only adds external interfaces — so gating it with a module-path prefix check is precise.\n\n2. **Filter-time filtering (Filter):** As defense-in-depth, add a module-path check in Filter that drops relations where the interface's PkgPath is neither local (module prefix) nor stdlib (when IncludeStdlib is set). This catches any edge cases where external interfaces leak through.\n\n3. **Module path propagation:** Read the module path once in Analyze and store it in Result. Filter reads it from Result. No changes needed to AnalyzeOptions or main.go.\n\n**Fallback:** If go.mod cannot be parsed (empty module path), skip module filtering and fall back to current behavior to avoid breaking anything.\n\n## Files to Modify\n\n### 1. `internal/analyzer/analyzer.go`\n- Add `readModulePath(dir string) string` helper function that reads `\u003cdir\u003e/go.mod` and extracts the `module` declaration using simple string parsing (no new dependencies needed — `golang.org/x/mod/modfile` is available as indirect dep but string parsing is simpler and sufficient)\n- At the start of `Analyze`, call `readModulePath(dir)` and log the result\n- Store the module path in the returned `Result.ModulePath`\n- In the imports loop (lines 124-129), add a guard: only call `collectFromScope` if `strings.HasPrefix(imp.PkgPath, modulePath)`. This filters out all external packages. Stdlib interfaces are already collected separately when IncludeStdlib is true (lines 31-38)\n- Add `\"os\"` to imports for `os.ReadFile`\n\n### 2. `internal/analyzer/types.go`\n- Add `ModulePath string` field to the `Result` struct\n\n### 3. `internal/analyzer/filter.go`\n- Add `isLocalPackage(pkgPath, modulePath string) bool` helper: returns true if modulePath is non-empty and pkgPath starts with modulePath\n- In Filter, after the stdlib check, add: if `result.ModulePath != \"\"` and the interface's PkgPath is not local and not stdlib → skip the relation\n- Propagate `result.ModulePath` to the filtered Result\n\n### 4. `internal/integration_test.go`\n- Add a new test case `12_external_deps` that verifies external package interfaces are excluded from the diagram\n- The test should:\n  1. Analyze a testdata dir containing Go code that imports an external package and implements its interfaces\n  2. Assert the diagram does NOT contain the external interface\n  3. Assert local interfaces still appear correctly\n\n### 5. `testdata/12_external_deps/` (new directory)\n- `go.mod`: `module example.com/testmod` with a require for a small external package (e.g., `github.com/stretchr/testify` or a simpler dep)\n- `main.go`: Define a local interface + type, and also a local type that satisfies an external interface (e.g., `fmt.Stringer` via stdlib, or define a struct with methods matching an external interface)\n- NOTE: For test simplicity, we can test with stdlib-as-proxy for external. The real fix is the module path check. Alternatively, create a mock scenario using synthetic Result data (similar to TestHubAndSpokeSlides) where external PkgPaths are manually set\n\n**Recommended test approach:** Use a synthetic/unit test (no testdata dir needed) that constructs a Result with mixed local and external interfaces, calls Filter, and asserts only local interfaces survive. This avoids needing real external deps in testdata. Add to `integration_test.go` alongside existing synthetic tests.\n\n### 6. `docs/architecture.md`\n- Update the `internal/analyzer (filter)` section to mention module-path filtering (external package exclusion)\n- Add a note about go.mod module path parsing in the `internal/analyzer` section\n\n## Dependencies\n\n- No new external packages needed. `go.mod` parsing uses simple string operations (`os.ReadFile` + `strings.Split` + `strings.HasPrefix`)\n- `golang.org/x/mod/modfile` is available as indirect dep but NOT needed for this simple parse\n\n## Edge Cases \u0026 Error Handling\n\n1. **go.mod not found or unparseable:** `readModulePath` returns empty string → all module-path filtering is skipped → current behavior preserved (no regression)\n2. **Module path with trailing slash:** `strings.HasPrefix` handles this correctly since Go module paths never end with `/`\n3. **Replace directives:** Replaced modules have their own module paths. If they're loaded by `./...`, their interfaces are collected in the main loop (not the imports loop). The imports loop guard only affects interfaces from imported packages, which are already separate from the local module\n4. **Multi-module repos:** `packages.Load(\"./...\")` respects the single module boundary defined by the go.mod in `dir`. Other modules in the repo are treated as external, which is correct\n5. **Vendor directory:** `go.mod` module path is still accurate regardless of vendoring mode\n6. **`builtin.error` interface:** Added at lines 132-150 with PkgPath \"builtin\". `isStdlib(\"builtin\")` returns true, so the stdlib filter already handles it. The new module-path filter won't affect it because `isStdlib` check runs first\n\n## Testing Strategy\n\n### Unit/Synthetic Tests (in integration_test.go)\n1. **TestExternalPackageFiltering:** Build a synthetic Result with:\n   - ModulePath: \"example.com/myapp\"\n   - Local interface: PkgPath \"example.com/myapp/store\", Name \"Repository\"\n   - External interface: PkgPath \"github.com/external/pkg\", Name \"Handler\"\n   - Local type: PkgPath \"example.com/myapp/impl\", Name \"SQLStore\"\n   - Relations: SQLStore→Repository (local), SQLStore→Handler (external)\n   - Call Filter → assert only the Repository relation survives\n   - Assert Handler interface is NOT in filtered result\n\n2. **TestReadModulePath:** Unit test for the go.mod parser:\n   - Valid go.mod → returns correct module path\n   - Missing go.mod → returns empty string\n   - Malformed go.mod → returns empty string\n\n3. **TestExternalImportsNotCollected:** Run Analyze on testdata/01_single_iface (which has no external deps) and verify Result.ModulePath is set correctly. This validates the plumbing without needing external deps.\n\n### Existing Tests\n- All existing tests should continue to pass unchanged since testdata modules have no external deps, so the new filter has no effect on them\n- The `07_stdlib_ifaces` tests verify stdlib filtering still works correctly alongside the new module filtering\n\n### Manual Verification\n- Run goifaces against a real repo with external deps (e.g., goifaces itself) and verify external interfaces don't appear\n- Run `bash scripts/visual-verify.sh` to check diagram rendering","status":"closed","priority":2,"issue_type":"bug","assignee":"falcon","owner":"olesho@gmail.com","created_at":"2026-02-21T08:22:32.289501-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-21T15:12:40.362441-06:00","closed_at":"2026-02-21T15:12:40.362441-06:00","close_reason":"Filter excludes external packages using module path from go.mod. Also handles dot-less module names (e.g. pentagi) correctly.","dependencies":[{"issue_id":"test-loom-cmz","depends_on_id":"test-loom-944","type":"blocks","created_at":"2026-02-21T08:23:35.103-06:00","created_by":"Oleh Luchkiv"}]}
{"id":"test-loom-co9","title":"Break large diagrams into paginated slides for readability","description":"Large diagrams like go-memdb produce a single very wide Mermaid chart that's too small to read. Need to split large diagrams into multiple slides/pages. Approach options: (1) Group by interface — each slide shows one interface and its implementors, (2) Group by package — each slide shows one package's types and interfaces, (3) Auto-partition by node count — split when diagram exceeds N nodes. The HTML server should add slide navigation (prev/next/overview). Each slide is a separate Mermaid diagram. An overview slide could show just the relationship graph without method details. Consider also adding a sidebar navigation listing all interfaces/types for quick jumping.","status":"closed","priority":2,"issue_type":"feature","owner":"olesho@gmail.com","created_at":"2026-02-19T16:27:53.624251-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:47:39.028799-06:00","closed_at":"2026-02-19T16:47:39.028799-06:00","close_reason":"Closed"}
{"id":"test-loom-dih","title":"Create project documentation","description":"CLAUDE.md (agent rules), AGENTS.md (agent workflow), docs/architecture.md, docs/cli-reference.md, docs/logging.md, docs/development.md, scripts/visual-verify.sh","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:06:39.4316-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:06:43.273698-06:00","closed_at":"2026-02-19T09:06:43.273698-06:00","close_reason":"All docs and scripts created"}
{"id":"test-loom-dl6","title":"Create integration test suite with 10 testdata scenarios","description":"internal/integration_test.go with 12 subtests across 10 testdata dirs. Each testdata dir is a self-contained Go module. Tests cover: single iface, multi impl, multi iface, pointer receiver, embedded iface, cross-package, stdlib ifaces (with/without), empty iface, unexported (with/without), diamond pattern.","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:06:32.183689-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:06:35.529773-06:00","closed_at":"2026-02-19T09:06:35.529773-06:00","close_reason":"All 12 tests passing. Fixed stdlib module paths, added stdlib package loading, and error builtin handling."}
{"id":"test-loom-f0x","title":"Color-code interfaces vs implementations in Mermaid diagrams","description":"Use Mermaid classDiagram styling (classDef + cssClass) to visually distinguish interfaces from concrete types. For example, interfaces in blue/teal and implementations in green/gray. This makes it immediately obvious which boxes are contracts vs implementations when viewing the diagram. Implementation is in internal/diagram/mermaid.go — add classDef statements after the classDiagram header and apply them to interface vs type nodes.","status":"closed","priority":2,"issue_type":"feature","owner":"olesho@gmail.com","created_at":"2026-02-19T11:43:00.117332-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T12:59:07.123668-06:00","closed_at":"2026-02-19T12:59:07.123668-06:00","close_reason":"Implemented in a20df86. Interfaces blue (#2374ab), implementations green (#4a9c6d) via Mermaid classDef + cssClass."}
{"id":"test-loom-f13","title":"Implement hub-and-spoke slide splitting strategy","description":"Implement the first concrete Splitter strategy: hub-and-spoke.\n\nAlgorithm:\n1. Classify nodes by connection count:\n   - 'Hub' nodes (reusable): interfaces/types with connections \u003e= threshold (e.g., 3+). These appear on EVERY slide as context.\n   - 'Spoke' nodes (non-reusable): implementations with fewer connections. These are chunked into groups.\n\n2. Group spoke nodes into chunks of N (configurable, default 3-4 per slide).\n\n3. For each chunk, build a slide containing:\n   - All hub nodes (the shared interfaces)\n   - The chunk's spoke nodes (implementations)\n   - Only the relations connecting these specific nodes\n\n4. Slide 0 remains the overview (all nodes, no methods).\n\nExample with go-memdb:\n- Hubs: memdb_Indexer, memdb_MultiIndexer, memdb_SingleIndexer, memdb_PrefixIndexer (4+ connections each)\n- Spokes: BoolFieldIndex, CompoundMultiIndex, ConditionalIndex, etc. (3 connections each)\n- Slides: chunks of 3 spokes + all hubs\n\nEdge cases:\n- A node that's both high-connectivity AND an implementation stays as a hub\n- ResultIterator + FilterIterator form their own small cluster — they should be grouped together\n- If total nodes \u003c= threshold, return single slide (no splitting)\n\nDepends on: splitter abstraction task.","status":"closed","priority":1,"issue_type":"feature","owner":"olesho@gmail.com","created_at":"2026-02-19T17:07:23.512936-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T19:19:24.213173-06:00","closed_at":"2026-02-19T19:19:24.213173-06:00","close_reason":"Implemented in hub-and-spoke slide splitting session: split package with Splitter interface, HubAndSpoke strategy, CLI flags, integration tests. All tests + linter pass.","dependencies":[{"issue_id":"test-loom-f13","depends_on_id":"test-loom-wa8","type":"blocks","created_at":"2026-02-19T17:07:38.275703-06:00","created_by":"Oleh Luchkiv"}]}
{"id":"test-loom-ije","title":"Replace dash-dotted arrow lines with solid ones in Mermaid diagrams","design":"## Summary\n\nReplace the Mermaid `..|\u003e` (dashed/dash-dotted realization arrow) with `--|\u003e` (solid inheritance arrow) in all generated class diagrams. Currently, `writeRelation` in `mermaid.go` uses `..|\u003e` which renders as a dashed line in Mermaid. The task asks for solid lines instead, which is `--|\u003e` in Mermaid syntax. This is a cosmetic change affecting diagram output only — no logic or architecture changes.\n\n## Technical Approach\n\nThis is a simple string replacement. In Mermaid classDiagram syntax:\n- `..|\u003e` = dashed line with open arrowhead (UML \"realization\")\n- `--|\u003e` = solid line with open arrowhead (UML \"inheritance\")\n\nThe single source of truth is the `writeRelation` function in `mermaid.go`. All tests that assert on the arrow syntax also need updating.\n\nNo new dependencies, no new patterns, no architectural decisions.\n\n## Files to Modify\n\n### 1. `goifaces/internal/diagram/mermaid.go` (line 188)\nChange the format string in `writeRelation` from `..|\u003e` to `--|\u003e`:\n```go\n// Before:\nline := fmt.Sprintf(\"    %s ..|\u003e %s\", typeID, ifaceID)\n// After:\nline := fmt.Sprintf(\"    %s --|\u003e %s\", typeID, ifaceID)\n```\nThis is the ONLY production code change.\n\n### 2. `goifaces/internal/integration_test.go` (multiple lines)\nUpdate all test assertions and the `normalizeOutput` helper to use `--|\u003e` instead of `..|\u003e`:\n\n**`normalizeOutput` function (line 82):** Change the relation-detection string:\n```go\n// Before:\n} else if strings.Contains(trimmed, \"..|\u003e\") {\n// After:\n} else if strings.Contains(trimmed, \"--|\u003e\") {\n```\n\n**All `assert.Contains` / `assert.NotContains` calls** that check for `..|\u003e` relations (lines 141, 153, 154, 170-176, 186, 199-201, 211, 236, 249, 260, 276-278, 291-293). Each `..|\u003e` becomes `--|\u003e`. Full list:\n- Line 141: `shapes_Circle ..|\u003e shapes_Shape` → `shapes_Circle --|\u003e shapes_Shape`\n- Line 153: `animals_Dog ..|\u003e animals_Speaker` → `animals_Dog --|\u003e animals_Speaker`\n- Line 154: `animals_Cat ..|\u003e animals_Speaker` → `animals_Cat --|\u003e animals_Speaker`\n- Line 170: `store_MemStore ..|\u003e store_Reader` → `store_MemStore --|\u003e store_Reader`\n- Line 171: `store_MemStore ..|\u003e store_Writer` → `store_MemStore --|\u003e store_Writer`\n- Line 172: `store_MemStore ..|\u003e store_ReadWriter` → `store_MemStore --|\u003e store_ReadWriter`\n- Line 174: `store_ReadOnlyCache ..|\u003e store_Reader` → `store_ReadOnlyCache --|\u003e store_Reader`\n- Line 175: `store_ReadOnlyCache ..|\u003e store_Writer` → `store_ReadOnlyCache --|\u003e store_Writer`\n- Line 176: `store_ReadOnlyCache ..|\u003e store_ReadWriter` → `store_ReadOnlyCache --|\u003e store_ReadWriter`\n- Line 186: `db_Connection ..|\u003e db_Closer` → `db_Connection --|\u003e db_Closer`\n- Line 199: `io2_MyFile ..|\u003e io2_Reader` → `io2_MyFile --|\u003e io2_Reader`\n- Line 200: `io2_MyFile ..|\u003e io2_Closer` → `io2_MyFile --|\u003e io2_Closer`\n- Line 201: `io2_MyFile ..|\u003e io2_ReadCloser` → `io2_MyFile --|\u003e io2_ReadCloser`\n- Line 211: `impl_ConsoleLogger ..|\u003e ifaces_Logger` → `impl_ConsoleLogger --|\u003e ifaces_Logger`\n- Line 236: `assert.NotContains(t, normalized, \"..|\u003e\")` → `assert.NotContains(t, normalized, \"--|\u003e\")`\n- Line 249: `assert.NotContains(t, normalized, \"..|\u003e\")` → `assert.NotContains(t, normalized, \"--|\u003e\")`\n- Line 260: `internal_Cat ..|\u003e internal_Runner` → `internal_Cat --|\u003e internal_Runner`\n- Line 276: `internal_dog ..|\u003e internal_walker` → `internal_dog --|\u003e internal_walker`\n- Line 277: `internal_dog ..|\u003e internal_Runner` → `internal_dog --|\u003e internal_Runner`\n- Line 278: `internal_Cat ..|\u003e internal_Runner` → `internal_Cat --|\u003e internal_Runner`\n- Line 291: `diamond_DB ..|\u003e diamond_Saver` → `diamond_DB --|\u003e diamond_Saver`\n- Line 292: `diamond_DB ..|\u003e diamond_Loader` → `diamond_DB --|\u003e diamond_Loader`\n- Line 293: `diamond_DB ..|\u003e diamond_Persister` → `diamond_DB --|\u003e diamond_Persister`\n\n## Files to Create\nNone.\n\n## Dependencies\nNone. No external packages needed. This is a pure string replacement.\n\n## Edge Cases \u0026 Error Handling\n- No edge cases — this is a deterministic string replacement with no conditional logic.\n- The `normalizeOutput` test helper in `integration_test.go` uses `..|\u003e` to detect relation lines during parsing. This MUST be updated to `--|\u003e` or the test normalizer will silently skip relation lines, causing false test passes.\n\n## Testing Strategy\n1. Run the full test suite: `cd goifaces \u0026\u0026 go test ./...`\n2. All 11 end-to-end test cases plus the hub-and-spoke slide test should pass.\n3. Manually verify by running the tool on any testdata directory and inspecting the output contains `--|\u003e` (solid arrows) instead of `..|\u003e` (dashed arrows).","notes":"BLOCKED: Source code files do not exist in the repository. The design references goifaces/internal/diagram/mermaid.go and goifaces/internal/integration_test.go, but the repo only contains the initial commit with .beads/issues.jsonl and AGENTS.md. All branches (main, nova, falcon, spark) point to the same initial commit. The goifaces project code was never committed to this repository. Cannot modify files that don't exist.","status":"closed","priority":2,"issue_type":"task","assignee":"nova","owner":"olesho@gmail.com","created_at":"2026-02-20T05:02:17.855914-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-20T13:17:06.228321-06:00","closed_at":"2026-02-20T13:17:06.228321-06:00","close_reason":"Replaced ..|\u003e with --|\u003e in mermaid.go and all test assertions"}
{"id":"test-loom-izp","title":"Wire splitter into main pipeline and test with go-memdb","description":"Wire the hub-and-spoke splitter into main.go and ServeSlides. Verify with go-memdb that:\n1. Overview slide shows all 17 nodes with no methods\n2. Each detail slide shows 3-4 implementations + the shared interfaces they connect to\n3. All relations are preserved (no missing arrows)\n4. Slides are navigable via prev/next/picker\n5. Each slide's Mermaid validates via scripts/verify-mermaid.sh\n\nAdd integration test: build slides for go-memdb-like synthetic data, assert slide count and hub presence on each slide.\n\nDepends on: hub-and-spoke implementation task.","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T17:07:28.151922-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T19:19:24.215067-06:00","closed_at":"2026-02-19T19:19:24.215067-06:00","close_reason":"Implemented in hub-and-spoke slide splitting session: split package with Splitter interface, HubAndSpoke strategy, CLI flags, integration tests. All tests + linter pass.","dependencies":[{"issue_id":"test-loom-izp","depends_on_id":"test-loom-f13","type":"blocks","created_at":"2026-02-19T17:07:38.349872-06:00","created_by":"Oleh Luchkiv"}]}
{"id":"test-loom-jzu","title":"Show file paths in Mermaid diagram blocks for interfaces and implementations","description":"Add source file path information to each class block in the generated Mermaid diagram. Both interface and implementation blocks should display the file path where they are defined. This requires: (1) capturing file position during analysis in analyzer.go (using go/packages token position info), (2) storing file path in InterfaceDef and TypeDef structs in types.go, (3) rendering the file path in the Mermaid class block in mermaid.go (e.g. as a note or first line in the block). The file path should be relative to the analyzed module root for readability.","status":"closed","priority":2,"issue_type":"feature","owner":"olesho@gmail.com","created_at":"2026-02-19T16:24:30.267171-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:43:48.378403-06:00","closed_at":"2026-02-19T16:43:48.378403-06:00","close_reason":"Closed"}
{"id":"test-loom-khd","title":"Package Map too wide, doesn't fit browser screen","description":"The Package Map visualization is too wide and overflows the browser viewport. Fix the layout/sizing so it fits within the screen and test in-browser to confirm.","design":"## Summary\n\nThe Package Map visualization (flowchart LR) generates an SVG whose natural width exceeds the browser viewport. The current JS fixup code explicitly sets each SVG's width to its viewBox pixel width and removes max-width constraints, causing horizontal overflow. The fix should auto-scale the Package Map SVG to fit the viewport while preserving the existing behavior for class-diagram slides (which benefit from 1:1 pixel rendering). This is a CSS/JS-only fix in server.go's HTML template.\n\n## Technical Approach\n\n**Strategy: Scale-to-fit for overflowing SVGs.**\n\nAfter Mermaid renders, compare each SVG's viewBox width to the available viewport width. If the SVG is wider than the viewport, instead of setting a fixed pixel width, set the SVG width to 100% and let the viewBox handle proportional scaling. For SVGs that fit within the viewport, keep the current behavior (exact pixel width for crisp text).\n\nThis approach:\n- Fixes the Package Map overflow without affecting detail slides that already fit\n- Requires no changes to the Go diagram generation code\n- Uses the browser's native SVG scaling (viewBox + width: 100%) for proportional fit\n- Preserves zoom in/out functionality (CSS transform scale still works on the container)\n\n**Alternative considered: CSS-only `max-width: 100%` on SVG.** Rejected because the current code explicitly sets `maxWidth = 'none'`, so a CSS rule would be overridden. The fix needs to be in the JS fixup logic.\n\n**Alternative considered: Change flowchart direction from LR to TB.** Rejected because TB makes the hierarchy harder to read and doesn't solve the root cause for repos with many packages.\n\n## Files to Create\n\nNone.\n\n## Files to Modify\n\n### `goifaces/internal/server/server.go` (lines ~521-533 in the JS section of slidesHTMLTemplate)\n\n**Change the SVG width fixup logic** in the `mermaid.run().then()` callback:\n\nCurrent code (problematic):\n```javascript\ndocument.querySelectorAll('pre.mermaid svg').forEach(function(svg) {\n  var vb = svg.getAttribute('viewBox');\n  if (vb) {\n    var w = parseFloat(vb.split(/\\s+/)[2]);\n    if (w \u003e 0) {\n      svg.style.width = w + 'px';\n      svg.style.maxWidth = 'none';\n    }\n  }\n});\n```\n\nNew code (scale-to-fit):\n```javascript\ndocument.querySelectorAll('pre.mermaid svg').forEach(function(svg) {\n  var vb = svg.getAttribute('viewBox');\n  if (vb) {\n    var w = parseFloat(vb.split(/\\s+/)[2]);\n    if (w \u003e 0) {\n      var available = svg.closest('.diagram-viewport').clientWidth - 32; // subtract padding\n      if (w \u003e available) {\n        // SVG is wider than viewport — let it scale down proportionally\n        svg.style.width = '100%';\n        svg.style.maxWidth = '100%';\n      } else {\n        // SVG fits — render at natural pixel width for crisp text\n        svg.style.width = w + 'px';\n        svg.style.maxWidth = 'none';\n      }\n    }\n  }\n});\n```\n\nThis compares the SVG's natural width (from viewBox) to the available container width. If the SVG overflows, it sets `width: 100%` so the browser scales it down using the viewBox. If it fits, it keeps the original crisp pixel-width behavior.\n\n### `goifaces/internal/server/server.go` (CSS section, `.diagram-viewport`)\n\nNo CSS changes needed. The existing `overflow: auto` on `.diagram-viewport` serves as a fallback for extreme zoom levels.\n\n## Dependencies\n\n- This branch needs the Package Map feature from main (commit 0428e86 and caa3ef0) merged in before implementation\n- No external packages needed\n\n## Edge Cases \u0026 Error Handling\n\n1. **Window resize**: The fix is applied once after Mermaid renders. If the user resizes the browser window, the SVG won't re-adapt. This is acceptable for v1 — the user can refresh. If desired later, add a `resize` event listener that re-runs the width check.\n\n2. **Zoom interaction**: When the user zooms in (CSS transform scale), the SVG container grows. Since we set `width: 100%` on the SVG, it stays within the container boundaries and the zoom transform scales it up correctly. The `.diagram-viewport`'s `overflow: auto` provides scrollbars if the zoomed content exceeds the viewport.\n\n3. **Very small viewports**: On extremely narrow screens, the scaled-down flowchart text may become unreadable. The existing zoom-in button handles this — user can zoom in and scroll.\n\n4. **SVGs without viewBox**: The `if (vb)` guard already handles this — SVGs without a viewBox are left untouched.\n\n5. **Detail slides (class diagrams)**: These are typically narrower than the Package Map and will likely pass the `w \u003e available` check as false, preserving their current crisp rendering.\n\n## Testing Strategy\n\n### Manual Testing (Primary)\n1. Merge the Package Map feature from main into the working branch\n2. Run `goifaces` against a repo with many packages (e.g., the goifaces repo itself or a larger repo)\n3. Open in browser and verify:\n   - Package Map (slide 0) fits within the viewport without horizontal scrollbar\n   - Detail slides still render at full resolution (no unnecessary scaling)\n   - Zoom in/out works correctly on both Package Map and detail slides\n   - Keyboard navigation (arrow keys) still works\n4. Test at different browser widths (resize window) to confirm the fix works at various sizes\n\n### Automated Testing\n- Existing integration tests in `internal/integration_test.go` verify Mermaid generation — these should still pass since we're only changing client-side JS, not the Go diagram generation\n- Run `go test ./...` to confirm no regressions","status":"closed","priority":2,"issue_type":"bug","assignee":"nova","owner":"olesho@gmail.com","created_at":"2026-02-21T08:25:11.589696-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-21T09:00:08.642221-06:00","closed_at":"2026-02-21T09:00:08.642221-06:00","close_reason":"Fixed SVG width scaling: wide diagrams now scale to fit viewport while narrow ones keep crisp pixel-width rendering","dependencies":[{"issue_id":"test-loom-khd","depends_on_id":"test-loom-944","type":"blocks","created_at":"2026-02-21T08:25:15.178489-06:00","created_by":"Oleh Luchkiv"}]}
{"id":"test-loom-klm","title":"Cache cloned repos and use git pull instead of re-cloning","description":"When analyzing a remote GitHub repo, cache the clone in a stable location instead of a temp dir. On subsequent runs for the same repo, just git pull to update instead of a full clone. This avoids re-downloading large repos every time.","status":"closed","priority":2,"issue_type":"feature","owner":"olesho@gmail.com","created_at":"2026-02-21T09:03:12.927259-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-21T09:04:44.817288-06:00","closed_at":"2026-02-21T09:04:44.817288-06:00","close_reason":"Repos cached in ~/.cache/goifaces/repos/\u003chash\u003e. Second run uses git fetch + reset instead of full clone."}
{"id":"test-loom-mce","title":"Smoke test goifaces against real Go repositories","description":"Test the binary against real repos: 1) ./goifaces https://github.com/hashicorp/go-memdb 2) ./goifaces on the goifaces project itself 3) A large repo to stress-test. Verify diagrams render correctly, logs are valid JSONL, and edge cases (compile errors, missing deps) produce warnings not crashes.","status":"closed","priority":2,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:41.428593-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T16:48:48.592292-06:00","closed_at":"2026-02-19T16:48:48.592292-06:00","close_reason":"Closed"}
{"id":"test-loom-php","title":"Remove orphaned interfaces from chart slides","description":"Each generated slide might contain orphaned interfaces - those which don't have any implementation (struct/type) related to them on that slide. Remove such interfaces from the chart. This logic should be applied per-slide: if an interface has no implementing type on a given slide, it should be excluded from that slide's Mermaid diagram.","design":"## Summary\n\nWhen slides are split using the HubAndSpoke strategy, hub interfaces are replicated onto EVERY detail slide. However, on any given slide, some of these hub interfaces may have no implementing type (spoke) present. For example, if PrefixIndexer is a hub interface connected to 4 types, but a slide only contains 3 types that don't implement PrefixIndexer, then PrefixIndexer appears as an orphaned node with no arrows. This task removes such per-slide orphaned interfaces so each detail slide only shows interfaces that have at least one implementing type on that slide.\n\n## Technical Approach\n\n**Where to apply the fix:** In `subResultForSplitGroup()` in `internal/diagram/slides.go`.\n\nThis function already correctly filters relations to only those where both the interface AND type are present in the group. The problem is that `sub.Interfaces` includes ALL interfaces from the group's `HubKeys`, even if none of their relations survived the relation filter. The fix is a post-filter step: after collecting relations, build a set of interface keys that participate in at least one relation, then trim `sub.Interfaces` to only those.\n\n**Why this location:** The splitter's job is node classification (hub vs spoke). The `subResultForSplitGroup` function is responsible for producing the final per-slide Result. Filtering orphans at this stage is clean, doesn't change the splitter contract, and naturally applies only to detail slides (the overview slide and full diagram slide don't go through this function).\n\n**Why NOT touch the splitter:** Hub interfaces should remain in every group's HubKeys for the splitter's correctness — they may have relations on some slides but not others. Removing them from HubKeys would break the splitter abstraction. The filtering belongs at the Result-assembly level.\n\n**Trade-off:** An interface might appear on zero detail slides if it's a hub but all its implementing types happen to share slides with other types. This is acceptable — the interface still appears on the overview slide, and showing it on a detail slide with no connections would be confusing.\n\n## Files to Modify\n\n### 1. `goifaces/internal/diagram/slides.go`\n**Function: `subResultForSplitGroup()`** (lines 66-106)\n\nAfter the existing relation-filtering loop (lines 97-103), add a post-filter step:\n1. Build a set of interface keys that appear in at least one relation in `sub.Relations`\n2. Filter `sub.Interfaces` to only those whose key is in that set\n\nPseudocode:\n```go\n// After the existing relation loop...\n\n// Post-filter: remove interfaces with no relations on this slide\nusedIfaces := make(map[string]bool)\nfor _, rel := range sub.Relations {\n    ik := typeKey(rel.Interface.PkgPath, rel.Interface.Name)\n    usedIfaces[ik] = true\n}\nvar filteredIfaces []analyzer.InterfaceDef\nfor _, iface := range sub.Interfaces {\n    ik := typeKey(iface.PkgPath, iface.Name)\n    if usedIfaces[ik] {\n        filteredIfaces = append(filteredIfaces, iface)\n    }\n}\nsub.Interfaces = filteredIfaces\n```\n\nThis is ~10 lines of straightforward Go. No new functions needed.\n\n## Files to Create\n\nNone.\n\n## Dependencies\n\nNo external packages needed. This uses only existing data structures and patterns.\n\n## Edge Cases \u0026 Error Handling\n\n1. **Interface on zero detail slides:** If a hub interface's implementing types all cluster onto slides where they share other hubs, the interface may not appear on any detail slide. This is correct — it still shows on the overview slide.\n\n2. **Non-hub interfaces:** These are attached to chunks based on their connected types, so they should always have at least one relation on their slide. The post-filter handles the edge case where this invariant breaks (e.g., if the attachment logic has a bug).\n\n3. **Empty sub.Relations:** If a group has no surviving relations (unusual but possible), all interfaces get filtered out, leaving an empty diagram. This is correct behavior — an empty slide would be pruned or show only type blocks.\n\n4. **Overview slide:** Not affected — `generateOverviewMermaid()` is called directly on the full result, not through `subResultForSplitGroup()`.\n\n5. **Full diagram (single-slide mode):** Not affected — uses `GenerateMermaid()` directly on the full filtered result.\n\n## Testing Strategy\n\n### Update existing test\n**`TestHubAndSpokeSlides` in `internal/integration_test.go`** (lines 322-439):\nThe current test asserts all 4 hub interfaces appear on EVERY detail slide. After the fix, only hubs with implementing types on that slide should appear. Update the test to:\n- Instead of asserting all hubs on all slides, verify that each hub appears only on slides where it has at least one connected type\n- PrefixIndexer connects to: StringFieldIndex, StringMapFieldIndex, StringSliceFieldIndex, CompoundIndex — should only appear on slides containing these types\n- ResultIterator connects to: FilterIterator — should only appear on the slide containing FilterIterator\n- Indexer, MultiIndexer, SingleIndexer connect to all 11 field index types — should appear on all slides except the one with only FilterIterator (if such a slide exists)\n\n### Add new targeted test\nAdd a test `TestOrphanedInterfacesRemovedFromSlides` in `internal/integration_test.go` that:\n1. Creates a synthetic result with 2 hub interfaces (A connects to X,Y,Z; B connects to only Z)\n2. Splits into groups where X,Y are on slide 1 and Z is on slide 2\n3. Asserts: slide 1 contains hub A but NOT hub B (B is orphaned on slide 1)\n4. Asserts: slide 2 contains both hub A and hub B\n\n### Visual verification\nRun `bash scripts/visual-verify.sh` after implementation to confirm SVG output looks clean.\n\n### Manual verification\nRun the tool against a real Go repo (e.g., go-memdb) and visually inspect that detail slides no longer show disconnected interface nodes.","status":"closed","priority":2,"issue_type":"task","assignee":"nova","owner":"olesho@gmail.com","created_at":"2026-02-21T08:09:56.652447-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-21T08:22:22.404388-06:00","closed_at":"2026-02-21T08:22:22.404388-06:00","close_reason":"Completed with tests and code review"}
{"id":"test-loom-snp","title":"Scaffold goifaces project structure","description":"go mod init, directory structure, .golangci.yml, .githooks/pre-commit, .gitignore, git init with custom hooks path","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:22.110035-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:05:26.501622-06:00","closed_at":"2026-02-19T09:05:26.501622-06:00","close_reason":"Project scaffolded with all dirs, configs, and git hooks"}
{"id":"test-loom-ume","title":"Add subtle color variability to Package Map blocks","description":"The blocks in the Package Map visualization are hard to differentiate from each other. Add color variability so each block has a distinct but subtle color when generating the chart. Keep colors muted/pastel — don't make them too bright.","design":"## Summary\n\nAdd subtle color variability to Package Map blocks so each package node has a distinct but muted/pastel background color. Currently all blocks use Mermaid's default white/grey styling, making packages hard to differentiate visually. After this change, each leaf and subgraph node in the Package Map flowchart will get a unique pastel color from a predefined palette, applied via Mermaid's `style` directive for leaf nodes and `classDef`/`class` for subgraphs.\n\n## Technical Approach\n\n**Approach:** Use Mermaid's inline `style` statements for leaf nodes and `classDef`/`class` for subgraphs to assign per-node colors from a fixed palette of muted/pastel colors. The colors cycle deterministically based on sorted package order, ensuring consistent output across runs.\n\n**Palette:** Define a Go slice of ~10 pastel color structs (`{fill, stroke, textColor}`), e.g.:\n- `#e8f4fd` / `#b8d4e8` (light blue)\n- `#e8f5e9` / `#b8d8ba` (light green)\n- `#fff3e0` / `#e8c9a0` (light orange)\n- `#f3e5f5` / `#d1b3d8` (light purple)\n- `#fce4ec` / `#e8b0bf` (light pink)\n- `#e0f2f1` / `#b0d4d1` (light teal)\n- `#fff9c4` / `#e8dea0` (light yellow)\n- `#e8eaf6` / `#b8bce8` (light indigo)\n- `#efebe9` / `#c8b8ad` (light brown)\n- `#f1f8e9` / `#c4dba0` (light lime)\n\nAll text stays `#333333` (dark) for readability on pastel backgrounds. These are intentionally muted — not bright or saturated.\n\n**Color assignment:** Each node (leaf node or subgraph) gets assigned a color index based on its position in the sorted package list, cycling through the palette with modulo. Subgraphs that are purely organizational (no stats, only children) still get a color so they're visually distinct containers.\n\n**Implementation strategy:**\n- For **leaf nodes** (no children): append a `style \u003cnodeID\u003e fill:\u003cfill\u003e,stroke:\u003cstroke\u003e,color:\u003ctextColor\u003e` line after all nodes are rendered\n- For **subgraphs**: use `classDef` at the top of the flowchart to define color classes (`pkgColor0`, `pkgColor1`, etc.), then apply them to subgraphs via Mermaid's `class` statement. Mermaid v11 supports `class subgraphId className` to style subgraph backgrounds.\n\n**Trade-offs:**\n- Fixed palette vs hash-based: A fixed palette guarantees visually pleasing, tested colors. Hash-based could produce clashing colors. Fixed palette with modulo cycling is simpler and more predictable.\n- Inline `style` vs `classDef`: For leaf nodes, inline `style` is simplest since each node needs a unique color. For subgraphs, `classDef` + `class` is the supported Mermaid mechanism.\n- Color count (10): Enough variety for typical Go projects (5-15 packages). Beyond 10 packages, colors cycle — but adjacent packages in the tree are unlikely to share colors due to sorted ordering.\n\n## Files to Create\n\nNone. All changes fit within the existing `slides.go` file in the package map rendering functions.\n\n## Files to Modify\n\n### `goifaces/internal/diagram/slides.go` (on main branch)\n\n**1. Add a `pastelPalette` variable** (package-level):\nDefine a slice of structs `{Fill string, Stroke string, Text string}` with ~10 pastel color entries. Place near the existing `pkgStats` type.\n\n**2. Modify `generatePackageMapMermaid`**:\n- After building the tree and writing the `flowchart LR` header, emit `classDef` lines for each palette entry: `classDef pkgColor0 fill:#e8f4fd,stroke:#b8d4e8,color:#333333` etc.\n- Pass a color index counter (starting at 0) into `renderTree` so it can assign colors.\n- After the tree rendering, append `style` lines for leaf nodes and `class` lines for subgraphs collected during rendering.\n\n**3. Modify `renderTree`** signature and behavior:\n- Add a `*int` parameter for the color counter (pointer so it increments globally across recursion).\n- For each child node processed (both subgraphs and leaf nodes), record the node ID and its assigned color index in a collector slice (passed by pointer or returned).\n- The actual `style`/`class` lines should be collected and emitted after all subgraph declarations are complete (Mermaid requires style statements outside subgraph blocks).\n\nSpecifically, change `renderTree` to:\n```go\ntype nodeStyle struct {\n    id          string\n    colorIdx    int\n    isSubgraph  bool\n}\n\nfunc renderTree(b *strings.Builder, node *pkgNode, depth int, colorIdx *int, styles *[]nodeStyle)\n```\n\nIn each iteration:\n- Assign the current `*colorIdx` to this node\n- Append a `nodeStyle{id, *colorIdx, isSubgraph}` to the styles slice\n- Increment `*colorIdx`\n- After `renderTree` returns in `generatePackageMapMermaid`, iterate over collected styles and emit:\n  - For subgraphs: `\\n    class \u003cid\u003e pkgColor\u003cN\u003e`\n  - For leaf nodes: `\\n    style \u003cid\u003e fill:\u003cfill\u003e,stroke:\u003cstroke\u003e,color:\u003ctext\u003e`\n\n### `goifaces/internal/integration_test.go` (on main branch)\n\n**Update `TestHubAndSpokeSlides`:**\n- Add assertion that the package map contains `classDef pkgColor0` to verify color definitions are present.\n\n**Update `TestPackageMapMultiPackage`:**\n- Add assertions checking that:\n  - The output contains `classDef pkgColor0` (at least one color class defined)\n  - The output contains `style` or `class` lines (colors are applied)\n  - Multiple color classes are defined (at least 2 for multi-package repos)\n\n### `goifaces/docs/architecture.md`\n- Update the Package Map description to mention pastel color variability for visual differentiation.\n\n## Dependencies\n\n- No new external packages needed\n- Depends on Mermaid v11's support for `classDef`/`class` on subgraphs (already confirmed working in the project's existing browser rendering)\n- This change is compatible with the related bugs (test-loom-cmz for external package filtering, test-loom-khd for width) — colors are orthogonal to those fixes\n\n## Edge Cases \u0026 Error Handling\n\n1. **Single package:** Gets one color. No issue — still visually distinct from default grey.\n2. **More packages than palette colors (\u003e10):** Colors cycle via modulo. Adjacent packages in the tree may rarely share colors, but the tree nesting provides sufficient visual separation.\n3. **Empty package map (no types):** The early return for `len(stats) == 0` already handles this — returns bare `flowchart LR` with no nodes, no style statements needed.\n4. **Nested subgraph + leaf at same level:** Both get colors from the same counter, so they'll be different colors even when siblings.\n5. **IncludeInit mode (standalone .mmd files):** The `%%{init:}%%` directive uses base theme. The inline `style`/`classDef` statements override the theme defaults, which is the desired behavior.\n\n## Testing Strategy\n\n### Unit Tests (update existing in integration_test.go)\n1. **TestHubAndSpokeSlides:** Assert package map contains at least one `classDef pkgColor` definition\n2. **TestPackageMapMultiPackage:** Assert:\n   - Output contains `classDef pkgColor0` and `classDef pkgColor1` (multiple colors for multiple packages)\n   - Output contains `class` or `style` statements applying colors to nodes\n   - Color fill values are from the pastel palette (`#e8f4fd`, `#e8f5e9`, etc.)\n\n### Manual Verification\n3. Run `bash scripts/visual-verify.sh` after implementation to render SVGs\n4. Use Read tool on output SVGs to visually verify pastel colors appear\n5. Run the tool on a real Go project and verify in browser that:\n   - Each package block has a distinct pastel background\n   - Colors are muted/not too bright\n   - Text remains readable on all backgrounds\n   - Subgraph containers have colored backgrounds\n   - The visual effect is subtle and professional","status":"closed","priority":2,"issue_type":"task","assignee":"spark","owner":"olesho@gmail.com","created_at":"2026-02-21T08:29:49.201524-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-21T09:05:50.405836-06:00","closed_at":"2026-02-21T09:05:50.405836-06:00","close_reason":"Completed with tests and code review","dependencies":[{"issue_id":"test-loom-ume","depends_on_id":"test-loom-944","type":"blocks","created_at":"2026-02-21T08:29:52.215668-06:00","created_by":"Oleh Luchkiv"}]}
{"id":"test-loom-vnu","title":"Implement main.go CLI entry point","description":"main.go - flag parsing (path, port, filter, include-stdlib, include-unexported, output, no-browser, log-file, log-level), pipeline orchestration, signal handling","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T09:06:24.159055-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T09:06:27.84161-06:00","closed_at":"2026-02-19T09:06:27.84161-06:00","close_reason":"Full pipeline wired: resolve → analyze → filter → enrich → diagram → serve/write"}
{"id":"test-loom-wa8","title":"Design splitter abstraction as a decoupled module","description":"Create a Splitter interface in internal/diagram/split/ (new subpackage) that takes an *analyzer.Result and returns []Slide. The interface should be strategy-based so we can swap different splitting algorithms without touching the rest of the codebase.\n\nKey design:\n- type Splitter interface { Split(result *analyzer.Result, opts SplitOptions) []Slide }\n- SplitOptions carries config: max implementations per slide, min connections to be 'reusable', etc.\n- The existing BuildSlides() in slides.go becomes a thin wrapper that delegates to a Splitter\n- Splitters are composed in main.go, not hardcoded\n\nThis is the abstraction layer only — no concrete strategy implementation.","status":"closed","priority":1,"issue_type":"task","owner":"olesho@gmail.com","created_at":"2026-02-19T17:07:15.357225-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T19:19:24.209267-06:00","closed_at":"2026-02-19T19:19:24.209267-06:00","close_reason":"Implemented in hub-and-spoke slide splitting session: split package with Splitter interface, HubAndSpoke strategy, CLI flags, integration tests. All tests + linter pass."}
{"id":"test-loom-xf7","title":"Remove method names from implementation blocks in Mermaid diagrams","description":"Remove method names from implementation (green) blocks in Mermaid class diagrams. Methods are already shown in interface blocks, so impl blocks should only display the struct name. This reduces visual clutter especially for large repos like go-memdb.\n\nChanges needed:\n1. internal/diagram/mermaid.go - writeTypeBlock: stop writing method lines, just emit class name + source file comment. Remove now-unused buildRelevantMethodsMap function. Remove relevantSet passing from GenerateMermaid.\n2. internal/diagram/slides.go - generateOverviewMermaid: add 'direction LR' after classDiagram (was missed in previous LR change).\n3. internal/integration_test.go - TestHubAndSpokeSlides overview assertion (line 422) checks no '+' lines — still valid. Detail slide assertions are fine since methods come from interface blocks.\n4. Run go test ./..., golangci-lint run ./..., bash scripts/visual-verify.sh (rebuild binary first with go build -o goifaces .)\n5. Update docs/architecture.md to note impl blocks show only type names.\n\nNOTE: mermaid.go already has partial edits applied (buildRelevantMethodsMap removed, writeTypeBlock simplified, relevantSet removed from GenerateMermaid call). Verify the current state and complete any remaining work.","design":"## Summary\n\nThis task removes method names from implementation (green) blocks in Mermaid class diagrams. Methods are already shown in interface (blue) blocks, so repeating them in impl blocks is redundant visual clutter — especially for large repos like go-memdb with many implementations. The task also ensures slides.go has 'direction LR' in the overview diagram, and updates architecture documentation.\n\n**NOTE: The code changes described in the task description have already been applied to the codebase.** The implementing agent's primary job is to VERIFY the current state is correct and run the full validation pipeline (tests, lint, visual-verify).\n\n## Technical Approach\n\nThe approach is straightforward: `writeTypeBlock` in mermaid.go was simplified to only emit the struct name and source file comment — no method lines. The `buildRelevantMethodsMap` function (which built a lookup of methods to display on type blocks) was removed as it's no longer needed. The `relevantSet` parameter was removed from `GenerateMermaid`'s call chain.\n\nThis is safe because:\n- Interface blocks already display all method signatures with `+MethodName()` syntax\n- Relation arrows (`Type ..|\u003e Interface`) clearly show which types implement which interfaces\n- Removing duplicate method listings significantly declutters diagrams for repos with many implementations\n\n## Files to Create\n\nNone.\n\n## Files to Modify\n\nAll changes below appear to be ALREADY APPLIED. The implementing agent should verify each one:\n\n### 1. `internal/diagram/mermaid.go`\n**Verify current state:**\n- `writeTypeBlock` (lines 158-165): Should only write `class ID { }` with an optional `%% file:` comment. Should NOT call `writeMethodLines` or emit any `+MethodName()` lines.\n- `buildRelevantMethodsMap`: Should NOT exist anywhere in the file.\n- `GenerateMermaid` (line 23): Should NOT accept or pass a `relevantSet` parameter. The call to `writeTypeBlock` on line 84 should take only `(\u0026b, typ)`.\n- `writeMethodLines` should only be called from `writeInterfaceBlock` (line 151).\n\n**If any of the above are NOT already applied:** Apply the missing changes per the task description.\n\n### 2. `internal/diagram/slides.go`\n**Verify current state:**\n- `generateOverviewMermaid` should have `direction LR` after `classDiagram` (currently line 154).\n- Type blocks in the overview should be empty (no methods), which they already are by design of this function.\n\n### 3. `internal/integration_test.go`\n**Verify current state:**\n- Line 422: `assert.NotContains(t, overview, \"+\", \"overview should have no method lines\")` — this assertion validates overview has no method `+` lines. Should remain as-is.\n- All other test assertions check for method names like `Area()` in the full diagram output. These will still pass because methods appear in interface blocks (via `writeInterfaceBlock` → `writeMethodLines`).\n- No test changes needed.\n\n### 4. `docs/architecture.md`\n**Verify current state:**\n- Line 51 should contain text explaining that implementation blocks show only the type name and methods are omitted. Currently reads: \"implementation blocks (green) show only the type name -- methods are omitted from impl blocks because they are already listed in the interface blocks, reducing visual clutter.\"\n\n## Dependencies\n\n- No external packages needed\n- No internal module changes needed\n- No blocking tasks\n\n## Edge Cases \u0026 Error Handling\n\n1. **Types with no SourceFile:** `writeTypeBlock` handles this — the `%% file:` comment is conditional on `typ.SourceFile != \"\"`. Verify this still works.\n2. **Overview vs detail slides:** Overview diagrams (slides.go) already omit methods from both interface AND type blocks. Detail slides show methods only in interface blocks. Verify both render correctly.\n3. **Empty diagrams:** Tests 07 (no stdlib) and 08 (empty iface) produce empty diagrams — verify they still pass.\n\n## Testing Strategy\n\n### Automated Tests\nRun: `cd /Users/olehluchkiv/Work/test-loom/goifaces \u0026\u0026 go test ./...`\n\nKey tests to verify pass:\n- `TestEndToEnd` — all 11 subtests, especially:\n  - `01_single_iface`: confirms `Area()` still appears (in interface block)\n  - `11_source_file_path`: confirms `%% file:` comments still appear\n- `TestHubAndSpokeSlides` — especially line 422 assertion that overview has no `+` method lines\n\n### Lint\nRun: `cd /Users/olehluchkiv/Work/test-loom/goifaces \u0026\u0026 golangci-lint run ./...`\n\n### Visual Verification\nRun:\n```bash\ncd /Users/olehluchkiv/Work/test-loom/goifaces\ngo build -o goifaces .\nbash scripts/visual-verify.sh\n```\nThen read a few output SVGs (e.g., `testdata/01_single_iface/output.svg`, `testdata/03_multi_iface/output.svg`) to visually confirm:\n- Interface blocks (blue) show method signatures\n- Implementation blocks (green) show ONLY the type name (no methods)\n- Relation arrows are intact\n\n### Manual Spot-Check\nAfter visual-verify, read the raw `.mmd` output for `testdata/01_single_iface/output.mmd` and verify:\n- The Shape interface block contains `+Area()` \n- The Circle impl block does NOT contain `+Area()` — only the class name and `%% file:` comment","status":"closed","priority":2,"issue_type":"task","assignee":"spark","owner":"olesho@gmail.com","created_at":"2026-02-20T04:56:36.227111-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-20T13:16:25.010019-06:00","closed_at":"2026-02-20T13:16:25.010019-06:00","close_reason":"Verified all code changes already applied. Tests pass, lint clean, visual-verify correct. Code review: no issues."}
{"id":"test-loom-xp4","title":"Support flags after positional arguments in CLI","description":"Go's flag package stops parsing at the first non-flag argument, so 'goifaces ./path -output file.md' doesn't work — flags must come before the positional arg. Consider switching to pflag or manually parsing args to support both orderings.","status":"closed","priority":3,"issue_type":"bug","owner":"olesho@gmail.com","created_at":"2026-02-19T09:05:42.944588-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T11:04:29.439666-06:00","closed_at":"2026-02-19T11:04:29.439666-06:00","close_reason":"Fixed in 045b6fb. Added reorderArgs() to support flags in any position."}
{"id":"test-loom-ymy","title":"Remote repo cloning fails to resolve Go module - packages not loaded","description":"When analyzing a remote GitHub repo (e.g. https://github.com/vxcontrol/pentagi), the tool clones successfully but fails at go mod download with 'no modules specified' and package loading fails with 'directory prefix . does not contain main module'. The tool likely isn't setting the working directory to the cloned repo path before running Go commands. Repro: ./goifaces https://github.com/vxcontrol/pentagi -port 8084","design":"## Summary\n\nWhen goifaces receives a remote GitHub URL, cloneRepo() clones the repo to a temp directory and returns that directory directly. For repos where go.mod is in a subdirectory (e.g. pentagi has go.mod at backend/), the returned directory has no go.mod, causing go mod download to fail with 'no modules specified' and packages.Load to fail with 'directory prefix . does not contain main module'. The fix: after cloning, search the cloned tree for go.mod and return the module root, mirroring how the local path handler already works.\n\n## Technical Approach\n\nThe local path handler (resolver.go lines 37-50) already correctly calls findModuleRoot(absPath) which walks UP parent directories to find go.mod. For cloned repos, we need to walk DOWN from the repo root since go.mod may be in a subdirectory.\n\n**Approach**: Add a new findModuleRootInTree() function that searches downward through the cloned repo for go.mod files. Then update cloneRepo() to call it after cloning, before running go mod download. This mirrors the existing pattern in the local path handler.\n\n**Key design decisions**:\n- Search downward (breadth-first) to find the shallowest go.mod, which is most likely the primary module\n- Skip vendor/ and .git/ directories during the search\n- If go.mod is at the repo root, this is a no-op (same as current behavior)\n- If multiple go.mod files exist at different depths, pick the shallowest one\n- If multiple go.mod files exist at the SAME depth, log a warning and pick the first one found (alphabetically sorted for determinism)\n\n## Files to Modify\n\n### 1. goifaces/internal/resolver/resolver.go\n\n**Changes needed in cloneRepo() (lines 58-84):**\n- After the git clone succeeds (line 77), call a new findModuleRootInTree(tmpDir) function\n- Use the returned module root path for goModDownload() instead of tmpDir\n- Return the module root path instead of tmpDir\n- Keep tmpDir for the cleanup function (we still want to clean the whole clone)\n\nThe updated cloneRepo() should look like:\n```go\nfunc cloneRepo(ctx context.Context, url string, logger *slog.Logger) (string, func(), error) {\n    tmpDir, err := os.MkdirTemp(\"\", \"goifaces-clone-*\")\n    if err != nil {\n        return \"\", func() {}, fmt.Errorf(\"creating temp dir: %w\", err)\n    }\n\n    cleanup := func() {\n        _ = os.RemoveAll(tmpDir)\n    }\n\n    logger.Info(\"cloning repository\", \"url\", url, \"dest\", tmpDir)\n\n    cmd := exec.CommandContext(ctx, \"git\", \"clone\", \"--depth=1\", url, tmpDir)\n    cmd.Stderr = os.Stderr\n    if err := cmd.Run(); err != nil {\n        cleanup()\n        return \"\", func() {}, fmt.Errorf(\"git clone: %w\", err)\n    }\n\n    logger.Info(\"clone complete\", \"dest\", tmpDir)\n\n    // Find module root (go.mod) in the cloned tree\n    modRoot, err := findModuleRootInTree(tmpDir)\n    if err != nil {\n        cleanup()\n        return \"\", func() {}, fmt.Errorf(\"finding module root in cloned repo: %w\", err)\n    }\n\n    logger.Info(\"found module root\", \"module_root\", modRoot)\n\n    if err := goModDownload(ctx, modRoot, logger); err != nil {\n        logger.Warn(\"go mod download failed\", \"error\", err)\n    }\n\n    return modRoot, cleanup, nil\n}\n```\n\n**New function findModuleRootInTree():**\nAdd this function after the existing findModuleRoot() function. It does a breadth-first search of the directory tree looking for go.mod files:\n\n```go\n// findModuleRootInTree searches downward from root for the shallowest go.mod file.\n// This is used for cloned repos where go.mod may be in a subdirectory.\nfunc findModuleRootInTree(root string) (string, error) {\n    // First check the root itself (most common case)\n    if _, err := os.Stat(filepath.Join(root, \"go.mod\")); err == nil {\n        return root, nil\n    }\n\n    // BFS through subdirectories to find the shallowest go.mod\n    queue := []string{root}\n    for len(queue) \u003e 0 {\n        var nextLevel []string\n        var candidates []string\n\n        for _, dir := range queue {\n            entries, err := os.ReadDir(dir)\n            if err != nil {\n                continue\n            }\n            for _, entry := range entries {\n                if !entry.IsDir() {\n                    continue\n                }\n                name := entry.Name()\n                // Skip non-module directories\n                if name == \".git\" || name == \"vendor\" || name == \"node_modules\" || name[0] == '.' {\n                    continue\n                }\n                subdir := filepath.Join(dir, name)\n                if _, err := os.Stat(filepath.Join(subdir, \"go.mod\")); err == nil {\n                    candidates = append(candidates, subdir)\n                } else {\n                    nextLevel = append(nextLevel, subdir)\n                }\n            }\n        }\n\n        if len(candidates) \u003e 0 {\n            sort.Strings(candidates)\n            return candidates[0], nil\n        }\n        queue = nextLevel\n    }\n\n    return \"\", fmt.Errorf(\"no go.mod found in %s or any subdirectory\", root)\n}\n```\n\nNote: The sort import is already present in resolver.go (line 10 currently has strings; we need to add \"sort\").\n\nWait, checking the imports: the file has \"strings\" but not \"sort\". We need to add \"sort\" to the imports.\n\n## Files to Create\n\nNone.\n\n## Dependencies\n\n- No new external packages needed\n- \"sort\" from stdlib needs to be added to imports in resolver.go\n\n## Edge Cases \u0026 Error Handling\n\n1. **go.mod at repo root** (most common case): findModuleRootInTree checks root first, returning immediately. Zero behavior change.\n2. **go.mod in a subdirectory** (the bug case): BFS finds the shallowest go.mod and returns its directory.\n3. **Multiple go.mod at same depth**: Sort alphabetically and pick the first. Log a warning. This is a rare edge case but provides deterministic behavior.\n4. **No go.mod anywhere**: Return a clear error message. This handles repos that aren't Go projects.\n5. **Symlinks in repo**: os.ReadDir doesn't follow symlinks by default, which is the safe behavior for cloned repos.\n6. **Very deep directory trees**: BFS naturally handles this; the shallowest module is found first.\n7. **Hidden directories** (starting with .): Skipped to avoid searching .git and similar.\n\n## Testing Strategy\n\n### Unit Tests (add to resolver_test.go or a new file)\n\n1. **Test findModuleRootInTree with go.mod at root**: Create temp dir with go.mod at root, verify it returns root.\n2. **Test findModuleRootInTree with go.mod in subdirectory**: Create temp dir with go.mod in subdir/go.mod, verify it returns subdir path.\n3. **Test findModuleRootInTree with no go.mod**: Create empty temp dir, verify it returns error.\n4. **Test findModuleRootInTree skips .git**: Create temp dir with .git/go.mod and real/go.mod, verify it returns real/.\n5. **Test findModuleRootInTree picks shallowest**: Create temp dir with a/go.mod and a/b/go.mod, verify it returns a/.\n\n### Manual Verification\n\n1. Test with a repo that has go.mod at root: `./goifaces https://github.com/some/simple-go-repo`\n2. Test with pentagi (the original failing case): `./goifaces https://github.com/vxcontrol/pentagi`\n3. Test with a local directory (regression): `./goifaces .`","status":"closed","priority":1,"issue_type":"bug","assignee":"falcon","owner":"olesho@gmail.com","created_at":"2026-02-20T16:30:51.025652-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-21T08:05:31.829556-06:00","closed_at":"2026-02-21T08:05:31.829556-06:00","close_reason":"Replaced shallow depth-1 findModuleRootRecursive with proper BFS that searches all subdirectory levels, skips .git/vendor/node_modules/hidden dirs, and sorts candidates for determinism. Added 6 unit tests."}
{"id":"test-loom-z87","title":"Slide threshold prevents splitting for go-memdb (17 nodes \u003c 20)","description":"go-memdb has 5 interfaces + 12 types = 17 nodes. The default slide threshold is 20, so BuildSlides returns a single Full Diagram slide and never invokes the splitter. The threshold should account for relation density, not just node count. A graph with 17 nodes and 38 relations is highly connected and benefits from splitting.","status":"closed","priority":1,"issue_type":"bug","owner":"olesho@gmail.com","created_at":"2026-02-19T19:29:55.026577-06:00","created_by":"Oleh Luchkiv","updated_at":"2026-02-19T19:31:45.835999-06:00","closed_at":"2026-02-19T19:31:45.835999-06:00","close_reason":"Fixed threshold check to also split when relation count \u003e= threshold. go-memdb (17 nodes, 38 relations) now produces 5 slides."}
